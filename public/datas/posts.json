{
	"closure": {
		"author": "",
		"body": "## Closure\n자바스크립트 함수는 함수 외부 변수에 접근하여 수정 변경이 가능한데 이 때, 수정가능한 변수가 담긴 렉시컬 환경(외부)의 범위를 클로저라고 한다. 클로저는 또한 외부 변수를 기억하고 그 변수에 접근할 수 있는 함수를 일컫기도 한다.  \n\n## Lexical Environment\n자바스크립트에서 실행중인 함수, 코드블록, 스크립트 전체는 렉시컬 환경(Lexical Environment)을 갖는다. 렉시컬 환경은 두 부분으로 구성되는데 하나는 코드 블록 내부를 표현하는 환경 레코드(Environment Record)로, 모든 지역변수의 프로퍼티를 갖고있고, 외부 렉시컬 환경(Outer Lexical Environment)는 외부 렉시컬 환경에 대한 참조를 담고있다. \n따라서 변수는 환경 레코드의 프로퍼티라고 볼 수 있다. 이 때문에 코드 블럭 내부의 변수를 외부 렉시컬 환경에서 불러올 수 없는 것이다. (지역 변수는 전역 환경 레코드에 프로퍼티가 아니며 외부 렉시컬 환경에도 포함되지 않기 때문에 전역 환경에서 지역변수를 불러 올 수 없다.) 다만, 블럭안에서 외부환경의 변수는 불러오는 것은 가능한데, 그 이유는 해당 렉시컬 레코드에서 변수를 찾지 못하면 외부 렉시컬 환경(Outer Lexical Environment)에서 그 변수를 찾으려 하고, 더이상의 외부 렉시컬 환경이 없을 때까지 반복되기 때문이다.\n\n## 렉시컬 환경과 함수\n그런데 이 특성은 함수의 불러올 수 있다는 특징과 만나 흥미로운 결과를 만든다. 함수는 선언될 자신이 선언된 위치의 렉시컬 환경을 `[[Environment]]`객체에 저장하게 된다. 그 뒤 함수가 실행되면 자신의 렉시컬 환경을 갖게 되는데, 특이한 점은 함수가 어디에서 실행 됐던, 자신이 선언된 위치의 렉시컬 환경을 `[[Environment]]`에 저장하고 있기 때문에 함수가 실행중인 위치와 전혀 상관없는 다른 위치의 렉시컬 환경에 영향을 받게 되는 것이다. \n```js\nfunction makeCounter()\n  let count = 0;\n\n  return function(){\n    return ++count;\n  }\n}\n\nlet counter = makeCounter();\n```\n위 상황에서 `return ++count;`의 한줄짜리 함수는 선언 될 때, `[[Environment]]`객체에 그 위체 대한 렉시컬 환경을 담게 된다. 이 후, `makeCounter`에 의해 만들어진 `counter`가 만들어 질 때, 함수의 렉시컬 환경을 갖게 된다. 따라서 원칙적으로 전역 환경에서 만들어진 `counter`함수는 함수 내의 `count`변수(`makeCounter`의 환결 레코드의 프로퍼티)에 접근할 수 없지만 `makeCounter`가 반환한 함수로 만들어진 `counter`함수는 `[[Environment]]`객체에 `makeCounter`의 렉시컬 환경을 담고 있으므로 `makeCounter`의 환경 레코드의 속성인 변수 `count`에 접근하며 변경할 수 있게 된다. \n\n\n## 화살표함수 \n화살표 함수가 일반 함수랑 다른점은 environment record에서 온다. 화살표함수의 환경레코드에는 일반 함수의 환경레코드와는 다르게 this, arguments object, super, new.target이 없다. \n\n### `arguments` 객체\n일반 함수는 전달인자를 받을때 자신만의 arguments 객체를 만들어 환경 레코드에 저장하는데 반해 화살표함수는 가진만의 arguments 객체를 가지지 못하고 외부 arguments 객체에 접근한다. 이때문에 아래와 같은 일이 생긴다.\n```js\nfunction myFunction() {\n  let arrowFunction = () => {\n    console.log(arguments);\n  };\n\n  arrowFunction(1, 2, 3);\n}\n\nmyFunction(4, 5, 6); // Output: [object Arguments] { 0: 1, 1: 2, 2: 3 }\n```\n화살표 함수의 logs가 가르키는 `arguments` 객체는 자신의 환경 레코드의 객체가 아닌 부모 렉시컬 환경에서 가지고 와야한다. 여기서 부모 렉시컬 환경은 `myFunction`의 렉시컬 환경이고, `myFunction`은 `arrowFunction`과 달리 환경 레코드에 자신만의 `arguments`객체를 가지므로 `arrowFunction`은 `myFunction`의 `arguments`객체에 접근하게 되는 것이다.\n\n### `this`\n 선언식으로 만들어진 매소드의 `this`는 함수가 불려진 객체를 나타낸다. \n```js\nlet myObject = {\n  prop: 'Hello',\n  myFunction: function() {\n    console.log(this.prop);\n  }\n};\n\nmyObject.myFunction(); // Output: 'Hello'\n```\n위 예제에서 `myObject`객체 안에 선언된 `myFunction`의 `this`는 `myFunction` 매소드가 호출될 때의 객체를 가르키게 된다. 하지만 화살표 함수로 선언된 매소드는 자신만의 `this`가 없다. 대신 화살표 함수를 감싸고 있는 함수의 `this`를 차용한다.\n```js\nlet user = {\n  firstName: \"보라\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // 보라\n```\n위에서 `arrow` 함수 안의 `this`는 `sayHi`함수의 `this`가 가르키는 객체를 사용한다. \n#### 객체 안의 화살표 함수.\n```js\nlet myObject = {\n  prop: 'Hello',\n  regularFunction: function() {\n    console.log(this.prop);\n  },\n  arrowFunction: () => {\n    console.log(this.prop);\n  }\n};\n\nmyObject.regularFunction(); // Output: 'Hello'\nmyObject.arrowFunction(); // Output: undefined\n```\n객체의 환경 레코드에는 `this`가 없다.\n#### 함수안의 객체안의 화살표 함수.\n```js\nobj = {\n  name: 'kim'\n  myFunction() {\n    let myObject = {\n      prop: 'Hello',\n      arrowFunction: () => {\n        console.log(this.name);\n      }\n    };\n\n  myObject.arrowFunction();\n  }\n}\n\nmyFunction(); // Output: kim\n```\n화살표 함수를 감싸는 `myFunction`함수의 `this`를 참조함.\n## Scope\n함수의 스코프란 함수가 접근가능한 환경레코드의 집합이라고 할 수 있다. 따라서 스코프는 렉시컬환경과는 약간 다른 개념이다. 위에서 설명 했듯이 함수가 선언될 때, 렉시컬환경의 범위는 내부 환경을 대변하는 환경레코드와 외부렉시컬환경의 참조로 이뤄지지만 만약 함수가 외부 렉시컬환경에서도 변수를 찾기 못하면 함수는 외부렉시컬환경의 외부렉시컬환경으로 변수를 찾아 나서기 때문이다. 이와같은 이유 때문에 스코프의 범위는 함수가 갖는 렉시컬환경 그 이상으로 확대된다.\n",
		"category": "posts",
		"createdAt": 1681115991498,
		"id": "closure",
		"tags": ["ES"],
		"title": "Closure"
	},
	"getserversideprops": {
		"author": "",
		"body": "`getServerSideProps`는 Next.js에서 제공하는 서버 사이드 렌더링(SSR)을 위한 함수이다. 이 함수는 각 요청에 대해 서버에서 실행되며, 페이지에 필요한 데이터를 가져와 페이지의 props를 통해 컴포넌트로 전달한다. \n\n## 렌더링\n보통 유저는 페이지가 자바스크립트 로드까지 끝난 뒤 자바스크립트를 통해 요청한 데이터를 기다린 후 데이터 fetch가 끝나면 페이지를 온전히 받을 수 있게 된다. 하지만 `getServerSideProps`로 데이터를 서버 측에서 요청한 데이터로 받을 수 있다면, 자바스크립트 로드를 기다리지 않는 다는 이점 하나만으로도 TTFB를 크게 줄일 수 있다. \n\n다음은 getServerSideProps의 기본적인 사용 방법이다.\n```js\nexport async function getStaticProps() {\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n\n  if (!data) {\n    return {\n      notFound: true,\n    }\n  }\n\n  return {\n    props: { data }, \n  }\n}\n```\n\ngetServerSideProps는 페이지의 초기 로딩 시에만 실행되며, 클라이언트 사이드 라우팅에서는 실행되지 않는다. 그러나 매 요청마다 서버에서 실행되므로, 트래픽이 많은 웹 사이트의 경우 서버에 부담을 줄 수 있다.\n## SEO\n\n클라이언트 사이드에서 API를 요청하는 경우, 크롤러가 페이지를 방문했을 때 데이터를 로딩하는 JavaScript 코드만 볼 수 있다. 이 경우 크롤러가 데이터를 인식하는 데 어려움이 있을 수 있다.\n반면에 서버 사이드에서 API를 요청하면, 크롤러가 방문했을 때 이미 완성된 HTML을 보게 되므로, SEO에 유리하다.\n\n\n## 다른 방법\nNext.js는 또한 getStaticProps라는 다른 데이터 가져오기 함수도 제공하는데, 이는 정적 생성(Static Generation, SSG)을 위한 것이다. getServerSideProps와 다르게 getStaticProps는 빌드 시에만 실행되므로, 요청마다 실행되지 않는다. 때문에, 가능한 경우 getStaticProps를 사용하는 것이 효율적일 수 있습니다.",
		"category": "posts",
		"createdAt": 1684902580873,
		"id": "getserversideprops",
		"tags": ["ETC"],
		"title": "getServerSideProps"
	},
	"global-snippet-setting": {
		"author": "",
		"body": "snippet으로 컴포넌트 등 자주 쓰는 코드 템플릿을 불러 올 수 있다.\n<img style=\"max-width:600px; width:100%\"\nsrc=\"https://velog.velcdn.com/images/latemarch/post/54997bb5-088c-4aec-adda-936d5e6f9afd/image.png\" />\n가령 위와 같이 리액트 함수 컴포넌트를 만들 수 있는 단축 구문을 `rfc`로 명명하여 snippets에 설정해 놓으면 파일명을 기반으로 빈 리액트 컴포넌트를 만들어 준다.\n<img style=\"max-width: 300px\" src=\"https://velog.velcdn.com/images/latemarch/post/95396407-79d6-43c9-b00e-53e3f0be18ad/image.png\"/>\n사용법은 간단하다. vscode의 커맨트 팔레트에 `snippets`로 들어와 `global.code-snippets`를 선택해 준다. 파일이 없으면 생성한다.\n\n![](https://velog.velcdn.com/images/latemarch/post/62daa918-6c6c-4c88-bd5b-29f6eb350539/image.png)\n![](https://velog.velcdn.com/images/latemarch/post/9fc3213f-f1b5-4a23-a287-6293a2fcc426/image.png)\n그리고 아래의 코드를 파일에 써준다.\n```js\n{\n\t\"reactFunction\": {\n\t\t\"prefix\": \"rfc\",\n\t\t\"body\": \"import React from 'react';\\n\\nexport default function ${1:${TM_FILENAME_BASE}}(){\\n\\treturn (\\n\\t\\t<div>\\n\\n\\t\\t</div>\\n)}\",\n\t\t\"description\": \"Creates a React Function component\"\n\t}\n}\n```\n이제 `prefix`의 값이 `body`를 작성하는 단축 구문이 된다. ",
		"category": "posts",
		"createdAt": 1681116095027,
		"id": "global-snippet-setting",
		"tags": ["ETC"],
		"title": "Global snippet setting"
	},
	"react-query": {
		"author": "",
		"body": "## React Query\n컴포넌트를 사용해 중복된 요소들을 쉽게 표현할 수 있지만, 컴포넌트는 자료의 재사용이 목적이 아니므로 컴포넌트에 서버에 api 요청을 하는 로직이 추가 되어 있는 경우, 개발자의 의도와는 다르게 과도한 요청이 일어날 수 있다. 이런 문제는 Query를 사용하여 비교적 쉽게 해결할 수 있다.   \n![](https://velog.velcdn.com/images/latemarch/post/865bfa34-1eb9-45a6-8c27-31ce64ef09bb/image.png)\n\n위 그림은 Query의 메인페이지 인데 그림에서 볼 수 있듯이 쿼리는 상태관리와 페칭, 비동기 코드들을 관리 한다. 사용자들은 쿼리를 주로 페칭, 캐싱, 비동기와 서버상태의 업데이트를 위해 사용한다. 쿼리를 이용하면 컴포넌트의 중복된 페치 요청을 막을 수 있는데 이는 쿼리가 요청한 자료를 캐싱하여 재요청 여부를 결정하기 때문이다. \n\n## Quick Start\n\n쿼리의 사용법은 기타 상태관리 library와 비슷하다.\n```js\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\n// Create a client\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n```\n`queryClient`를 만들어 주고, 이를 적용될 범위에 부모요소로 감싸줘 스코프 설정을 한다. 이렇게 되면 일단 쿼리를 사용할 준비는 끝난다. 그 뒤 쿼리를 사용할 컴포넌트에서 `useQuery`를 사용해 페치해준다.\n```js\nconst {isLoading, error, data} = useQuery(['data'], ftn)\n```\n`useQuery`는 많은 정보를 제공하지만 여기서는 로딩중인지, 에러가 났는지, 그리고 데이터를 받아온다. `useQuery`함수에는 배열 형태인 키와 페칭 함수를 전달인자로 받는다. 쿼리는 이제부터 페치한 데이터를 키를 기준으로 관리하게 된다. 동일 키를 가진 데이터에 대한 페치요청이 다시 발생하게 되면, 캐시된 데이터를 우선적으로 가져오는 방식이라 생각하면 된다.  \n\n## Important Defaults\n리액트 쿼리가 캐싱과 페칭을 관리해주는것은 사용자에게 굉장히 유익한 경험을 준다. 하지만 이런 경우 '어떤 키'로 페칭한 데이터에 대한 리페칭 이슈가 있을 수 있다. \n\n- <a href=\"https://tanstack.com/query/latest/docs/react/guides/important-defaults\">Query instances via `useQuery` or `useInfiniteQuery` by default consider cached data as stale.</a>\n\n한번 페칭이 일어난 데이터는 그 즉시 오래된(staled) 데이터로 간주되기 때문에 다음 요청에 바로 페칭이 일어나게 된다. (동일 렌더링에서는 한번만 요청한다.) 때문에 사용자가 의도한대로 선능 개선이 일어나지 않을 수 있으며, 상황에 따라 쿼리를 사용하기 전보다도 더 많은 api요청이 발생할 수도 있다. 따라서 페칭에 대한 관리도 사용자의 몫이 된다. 이를 위한 방법은 공식문서에 잘 나와있지만 여기에서는 가장 간단한 방법인 오래된(staled) 데이터로 간주하는 최소 시간을 설정해 주는 방법만 간단하게 소개한다.\n```js\nconst {isLoading, error, data} = useQuery(['data'], ftn, {staleTime:1000*60*1})\n```\n위와 같이 페칭 함수 뒤에 객체 형태로 조건을 넘겨줄 수 있는데, 쿼리는 이 조건에 따라 페칭 여부를 판단하게 된다.\n\n## 리액트 쿼리와 상태관리\n리액트는 그 자체적으로 데이터 페칭 기능을 제공해 주지 않기 때문에, 개발자가 직접 서버의 데이터를 가지고와 관리하는 방법을 강구해한다. 이는 보통 서버에서 가지고 온 데이터를 일반적인 상태관리 툴과 함께 사용하는 방법을 이용한다. 하지만 서버 데이터는 외부 데이터를 가지고 오는 과정을 거치므로 리액트 상태와는 달리 일반적인 상태관리 툴로 다루기에 적합하지 않다. 따라서 실시간으로 업데이트 되는 서버 상태를 클라이언트와 효과적으로 동기화 하기 위해 Query를 이용한다.\n\n공식 문서에 나온 방법과 같이 react Query 또한 다른 상태관리도구들과 같이 스코프 설정을 해서 서버로부터 가지고 온 데이터를 제공할 컴포넌트들을 정한다.\n\n```js\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n```\n따라서 <QueryClientProvier>로 스코프 설정 안에 들어있는 컴포넌트들은 query가 받아온 데이터를 공유하게 된다. 이같은 이유로 원한다면 리액트 상태들도 Query의 스코프 설정안에서 공유되어 Query를 전역상태도구로 사용할 수도 있지만 react Query는 서버 상태를 관리하는 목적으로 최적화 됐기 때문에 그 용도에 맞지 않다.\nreact Query는 키를 통해 데이터를 관리하게 된다.\n```js\nimport { getTodos } from '../my-api'\nconst query = useQuery('todos', getTodos)\n```\n위 예시에서 query에 담긴 데이터는 'todos'라는 키와 함께 캐시에 저장되어 관리된다. 키와 함께 효율적인 리프레시 설정하여 성능 향상을 가지고 올 수 있지만 반대로 캐시된 데이터 때문에 오히려 데이터 동기화 문제가 생길 수 있다.\n또한 react Query는 전역상태를 관리하는 목적으로 만들어 진게 아니기 때문에 Redux의 reducer나 action과 같은 전역상태 관리에 편의를 주는 기능들이 없다. 또한 서버 데이터 관리를 목적으로 만든만큼 전역상태를 관리할 때 성능측면에서도 좋지 않다고 하니 굳이 react Query를 고집하여 전역상태를 관리할 필요는 없다.\n\n## 쿼리 무효화 전략\n앞서 query에 담긴 데이터가 특정 키와 함께 캐시에 저장되어 데이터 동기화 문제를 야기한다고 했다. 이 점을 보완하기 위해서 특정 키와 일치하는 모든 쿼리를 무효화 한다. 무효화된 쿼리는 캐시에서 지워지지는 않지만 무효화된 쿼리를 대신할 새로운 쿼리를 구성하기 위해 리페치 과정이 유도되며 이 과정에서 리액트 컴포넌트의 적절한 리렌더링이 일어난다.\n\nuseQuery가 데이터를 가지고 오는 일은 하는 hook이라면, 서버 데이터에 변화를 주는 일에는 useMutation이 있다. 목적이 명확한 이 두 훅을 사용하면 앱에서 데이터를 가지고 오거나 변화를 주는 코드를 구분하기 쉽게하고 코드 유지보수를 쉽게 만들어준다. 또한 useMutation의 콜백함수인 onSuccess는 mutation이 성공적으로 이뤄졌을 때 호출되는데 이 콜백함수를 이용해 특정 queiry의 키를 무효화 할 수 있다. invalidateQueries를 사용하면 서버에서 데이터가 변경되었을 때 해당 변경 사항을 반영하도록 클라이언트 캐시를 새로 고칠 수 있다. 예를 들어, 데이터를 업데이트하는 뮤테이션을 실행한 후 해당 데이터에 대한 쿼리를 무효화하면 변경 사항이 반영된 새로운 데이터를 가져올 수 있다.\n\n## Query Custom Hook\n여느 훅과 같이 Query hook으로 같은 작업은 여러 컴포넌트에서 실행하는 경우가 있다. 특히 Query hook 같은 경우는 서버에서 데이터를 가지고 오는 작업이므로 react hooks보다 클라이언트 여러곳에서 더 빈번하게 사용되는 경우가 흔하다. 또한 Query hook은 위에서 본것과 같이 key를 통해 data fetching을 결정하므로 key를 관리하는 측면에서도 여러 곳에서 반복되어 사용되는 Query hook을 하나로 관리할 필요가 있다.",
		"category": "posts",
		"createdAt": 1681115765495,
		"id": "react-query",
		"tags": ["React"],
		"title": "React Query"
	},
	"react-redux": {
		"author": "",
		"body": "리덕스는 상태관리툴로 전역에 걸쳐 접근해야 하는 상태를 관리한다. 리덕스는 자바스크립트 환경에서 작동하기 때문에 리액트는 물론이고 vue, react native, angular와 같은 기타 프레임워크에서도 작동한다. 일단 자바스크립트에서의 리덕스의 기본 동작은 간단하다.\n## Javascript와 Redux\n```js\nimport {createStore} from 'redux'\n\nconst reducer = (state = 0) =>{\n  return state\n\n}\nconst store = createStore(reducer)\n```\n리덕스를 불러와 컨테이너(`store`)를 하나 만든다. 저장소를 만들때 함수를 하나 전달해 주는데 이 함수를 reducer 라고 부른다. 이 함수는 코드 시작과 함께 `store`에 저장된 `state`를 초기화 하면서 시작하고 이후에 `state`는 함수 `reducer`를 통해 수정(modify)된다.\n\n### 수정하기\n만들어진 컨테이너의 `state`를 변경하는 방법은 `action`이라는 객체를이용하는 것인데 이 객체를 사용하기 위에서는 `action` 객체를 `ruducer`함수에 넘겨주어야한다. `action` 객체는 일어날 일을 서술하고 있는 객체로, 함수가 아님에 주의해야한다. 아래애서 <a href='https://ko.redux.js.org/introduction/getting-started/'>공식문서</a>에 나오는 예제를 소개한다.\n```js\nimport {createStore} from 'redux'\n\nconst reducer = (state = 0, action) =>{\n  if (action.type === 'INCREMENT')\n    return state+1\n  return state\n\n}\nconst store = createStore(reducer)\nstore.dispatch({ type: 'INCREMENT' })\n```\n이제 우리의 첫번째 예제의 `reducer`함수에 `action`이라는 객체가 전달인자로 추가되었다. 이 `action`이라고 불리우는 객체는 위에서 설명 했듯이 무엇이 일어날지에 대한 서술을 담은 객체이다. `action`객체는 컨테이너 내장함수인 `dispatch`에 의해 `reducer`함수로 전달될 수 있다. 이제 `reducer`함수는 전달인자로 받은 객체의 속성을 토대로 `reducer`함 수 안에서 `state`를 변경할 수 있다면 기본적인 `redux`의 사용법을 익힌것이나 다름 없다.\n\n### state 적용하기\n```js\nimport {createStore} from 'redux'\n\nconst num = document.getElementById(\"number\")\n\nconst reducer = (state = 0, action) =>{\n  if (action.type === 'INCREMENT')\n    return state+1\n  return state\n\n}\nconst store = createStore(reducer)\nstore.dispatch({ type: 'INCREMENT' })\n\nstore.subscribe(()=> num.innerText = store.getState());\n```\n`state`는 위와 같이 `store`의 내장함수 `subscripbe`에 의해 `state`가 변경 될때마다 DOM으로 반영 될 수 있다. \n여기까지 자바스크립트에서 리덕스가 어떻게 작동 되는지 보았다. 요약하자면 \n\n1. 전역적으로 관리하고 싶은 `state`를 하나 만들어서 \n2. `reducer`를 통해 관리하는데 \n3. `action`이라는 객체에는 `reducer`가 `state`관리하는 방법이 담겨있다.\n4. 그리고 이 모든 것은 `store`에 담겨 있다.\n\n자바스크립트에서는 위와 같은 일들이 피교적 간단하게 해결되었지만 리엑트에선 리액트의 컴포넌트데이터 흐름이 단방향이라는 특징 때문에 간단하게 진행되지만은 않는다. 당장 생각해 봐도 리덕스가 리액트에서 어떻게 props drilling을 해결할지에 대한 이미지가 떠오르지 않는다. 당장 `store`와 `reducer`만이라도 각 컴포넌트에 전달되어야 할것 처럼 보이기 때문에 상태 끌어올리기만도 못해 보이기 때문이다. \n## React와 Redux\n### 그럼에도 원리는 같다.\n하지만 기본적인 구동방식은 동일하다. `state`는 `action`객체가 명명한 대로 `reducer`에 의해 수정되며 이 수정과정 또한 `dispatch`를 통해 수행된다. 또한 이런 상태, 객체, 함수들은 `slice`라는 함수에 묶여있어 `slice`내의 상태는 같은 `slice`내에 있는 `reducer`에 의해서만 변경되는 베타적인 성격을 가진다. 또한 이 `slice`는 `configureStore()`통해 생성된 `store`객체에 의해 관리될 수 있는데, `configureStore()`를 통해 생성된 `store`는 위의 상태,객체,함수등을 담는 용도 외에 리덕스에서 제공하는 여러 기능들을 담고있기도 하여 `configureStore()`이용해 리덕스 스토어를 관리하는 것이 공식문서에서 권장되고 있다. 요약하자면 리액트에서도 리덕스가 작동하는 방식은 결국 같다.\n\n1. 전역적으로 관리하고 싶은 `state`를 하나 만들고 \n2. `reducer`를 통해 관리하는데 \n3. `action`이라는 객체가 관리하는 명세서 같은 역할을 한다.\n3-1. 이 모든것은 `slice`함수에 베타적으로 작동한다.\n4. 그리고 이 모든 것은 (`configureStore()`에 의해 만들어진)`store`에 의해 묶여있다.\n\n### Redux Toolkit을 이용한 React환경에서 Redux구현\n이제부터 React에서 Redux를 쓰는 방법을 소개하고자 한다. 단계별로 진행 되는 과정에서 반드시 아래의 방법을 따르지 않아도 된다. 하지만 결국 `reducer`를 만들어 `state`를 관리한다는 점에서는 같다. \n\n1. `configureStore`를 이용해 빈 `sotre`를 만든다.\n2. `createSlice`에 초기상태와 `action`을 작성해 `reducer`에 넣어준다.\n3. `reducer`를 1번에서 만든 `store`에 넣어준다.\n4. 이제 리액트 컴포넌트에서 `useSelector`를 이용해 `state`에 접근하고, `useDispatch`를 이용해 변경할 수있다.\n\n상태관리 툴이 항상 그렇듯이 리덕스도 provider로 리덕스 컨테이너가 적용될 범위를 감싸줘야한다. 한번 만들어진 컨테이너(`store`)는 `Provider`를 통해 적정 컴포넌트에 접근 가능하게 만들어 줄 수 있다. 먼저 `store`를 만든다.\n```js\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport defualt configureStore({\n  reducer:{}\n})\n```\n이 `store`에는 `state`와 `action`을 담은 `reducer`가 추가되어야 하지만 일단은 빈 컨테이너로 놔두고 차차 진행해보기로 한다. 빈 컨테이너를 만들었다면 비록 비었지만 `적당한 컴포넌트`들이 이 컨테이너에 접근할 수 있게 하기위해 `Provider`를 이용해 `적당한 컴포넌트`들을 감싸준다.\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n//./app/store 파일에 리덕스 store를 만들어둠\nimport store from './app/store' \nimport { Provider } from 'react-redux'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n이렇게 앱을 감싸주게 되면 `App`과 그 하위 컴포넌트들은 이제 리덕스가 관리하는 상태에 접근하고 변경할 수 있게 된다. 컨테이너를 만들었으니, 이제 컨테이너를 채워보자. 위에서 설명했듯이 컨테이너는`reducer`를 담고있고 `reducer`는 `action`객체와 `state`를 담고있다.  \n\n### Redux State Slice\n`Slice`를 작성할 파일 하나를 추가하자. \n```js\nimport { createSlice } from '@reduxjs/toolkit'\n\nexport cont conterSlice = createSlice({\n  //state를 정의한다. 이제 counter라는 이름의 state는 state.value=0 으로 초기화 되었다. \n  name: 'counter'\n  initialState:{\n  \tvalue:0\n  \t//qty:0 와같이 추가로 속성을 더해주면 2개의 state를 하나의 slice로 관리하게 된다.\n    //이와같은 방법으로 여러개의 state를 하나의 slice에 묶어 관리할 수 있다.\n  },\n  reducer{\n    increment: state => {\n      state.value+=1                              \n    },\n    decrement: state => {\n      state.value-=1                              \n    }\n    incrementByAmount: (state, action) => {\n      state.value += action.payload\n    }\n  }\n})\n\n// createSlice()의 인스턴스인 couterSlice는 action을 자동으로 생성한다.\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport default counterSlice.reducer\n```\n이제 언뜻 보면 `slice`안에 `state`와 `action`을 담아준것 처럼 보이지만 사실 `slice`는`increment`와 같은 코드를 `action`으로 만들고 \"초기\"`state`를 받아 `reducer`를 \"만들어\"주는 역할을 한다. 이후에 `state`가 `reducer`에 의해 변경된다고 하더라도 `slice`내의 `initialState`객체는 변하지 않는다. \n\n### Store에 Reducer추가하기\n이제 우리의 비어있는 컨테이너에 슬라이스를 추가하기 위해 처음에 만들었던 빈 `store`에 `slice`를 불러 넣는다.\n```js\nimport { configureStore } from '@reduxjs/toolkit'\nimport coounterReducer from '../features/counter/counterSlice'\n\nexport defualt configureStore({\n  reducer:{\n    counter: counterReducer  //추가\n  }\n})\n```\n추가한 `reducer`함수에는 `state`와 `action`모두를 담고으므로 `store`가 필요한 정보들은 모두 넘겨준 셈이다. `Provider`로 공급중인 `store`에 `state`와 `reducer`가 있으니 이제 컴포넌트에서 `state`에 접근할 수있고 변경할 수 있는 조건들을 모두 충족했다.\n\n### React Components에서 Redux State 사용하기\n이제 `useSelector`를 이용해 `state`에 접근할 수 있으며, `useDispatch`를 통해 `state`를 변경할 수 있다.\n```js\nimport React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { decrement, increment } from './counterSlice'\nimport styles from './Counter.module.css'\n\nexport function Counter() {\n  const count = useSelector(state => state.counter.value)\n  const dispatch = useDispatch()\n\n  return (\n    <div>\n      <div>\n        <button\n          aria-label=\"Increment value\"\n          onClick={() => dispatch(increment())} // state 변경\n        >\n          Increment\n        </button>\n        <span>{count}</span>\n        <button\n          aria-label=\"Decrement value\"\n          onClick={() => dispatch(decrement())} // state 변경\n        >\n          Decrement\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n",
		"category": "posts",
		"createdAt": 1681115701129,
		"id": "react-redux",
		"tags": ["React"],
		"title": "React Redux"
	},
	"restful-api": {
		"author": "",
		"body": "RESTful하다 라는 말을 자주 듣게 되는데, 이때마다 의도는 알 수 있어도 그 의미는 분명하지 않았다. 하지만 RESTful 하다는 의미를 어느정도 알고난 뒤에 생각해 보니, 프론트엔드를 공부하면서 사실 restful 하지 못한 api를 써본 경험이 없는것 같다. 외부 서비스를 이용할 때, 날씨, youtube 등 몇가지 api를 써봤을때도 rest api를 제공 받았고, 학원에서 프로젝트를 진행 할 때에도 백엔드에서 제공하는 api들은 모두 rest api라고 여겨진다.(적어도 나는 그렇게 사용했다.)\n\n## REST 아키텍처\nrest api는 rest 아키텍처를 준수하는 api를 말한다. 이는 api가 만들어 질 때 어떤 방식, 언어, 라이브러리등과 상관없이 REST가 요구하는 원칙을 준수하며 만들기만 하면 그만이다. 다음은 대표적인 REST 아키텍처의 원칙이다.\n\n1. Client-Server: 클라이언트와 서버는 서로 독립적으로 존재하며, 각자가 발전하고 변화하는데 서로가 영향을 주지 않아야 합다. \n\n2. Stateless: 각 요청은 모든 필요한 정보를 포함해야 한다. 즉, 서버는 클라이언트의 상태를 저장하거나 이전 요청을 기억하지 않는다.\n\n3. Cacheable: 서버는 클라이언트가 응답을 재사용할 수 있도록 응답 데이터의 캐시 가능성을 명시해야 한다. \n\n4. Uniform Interface: REST API는 일관된 인터페이스를 제공해야 한다.\n\n\n## 프론트엔드 관점\n위의 원칙들과 더불어 어떤 원칙들은 사실 프론트엔드 입장에서는 잘 느끼지 못하는 경우가 있다. 특히 Cacheable의 서버 메모리측 캐싱 측면에서는 서버 메모리에 캐싱되어 클라이언트의 동일 요청에 서버 자원을 소모하지 않는 방법이라, 이런 경우는 클라이언트가 느끼기 힘든 부분이다. \n아래는 프론트엔드 관점에서 보는 RESTful한 api의 특징들이다.\n\n1. 자원 중심적(Resource Oriented): REST API는 웹의 자원을 URL로 표현하며, 이를 통해 웹 자원에 대한 쉬운 접근이 가능합니다. 이러한 접근 방식은 프론트엔드 개발자가 필요한 데이터를 쉽게 찾아볼 수 있게 합니다.\n\n2. 표준 HTTP 메소드 사용: REST API는 표준 HTTP 메소드(GET, POST, PUT, DELETE 등)를 이용하여 자원에 대한 CRUD(Create, Read, Update, Delete) 연산을 수행한다. \n\n3. 플랫폼 독립적: REST API는 플랫폼에 독립적이다. 따라서, 프론트엔드 개발자는 다양한 언어와 프레임워크(예: React, Vue, Angular 등)에서 동일한 REST API를 사용할 수 있다.\n\n4. 스케일아웃이 용이: REST는 무상태(Stateless) 통신 방식을 사용하므로 서버의 확장이 쉽다. 이는 프론트엔드 개발자가 사용자 수가 많아져도 API가 안정적으로 동작한다는 보장을 받게 한다.\n\n5. 캐시 사용 가능: REST API의 응답은 캐시 가능하므로, 프론트엔드 개발자는 이를 활용해 애플리케이션의 성능을 향상시킬 수 있다. \n\n6. Self-descriptive: REST API는 그 자체로 메시지가 충분한 정보를 포함하고 있어서 어떻게 처리해야 할지를 알 수 있다. 이는 프론트엔드 개발자가 API를 쉽게 이해하고 사용할 수 있도록 한다.\n\n다시말해 사용하기 편하고 독립적이며 확장성이 있는 \"좋은\" api를 만들라는 뜻이며 개발자들이 추구해야 할 권장되는 원칙 같은 것이다.",
		"category": "posts",
		"createdAt": 1685080495612,
		"id": "restful-api",
		"tags": ["ETC"],
		"title": "RESTful API"
	},
	"styled-component": {
		"author": "",
		"body": "## 기본 사용법\n```js\n// 기본 사용법\nconst Div = styled.div`\n\t/*style*/\n`\n\n// 상속하기\nconst Div2= styled(Div)`\n\t/*style*/\n`\n\n// Attributions 넣기\nconst InputWithAttrs = styled.div.attrs({required : true})`\n\t/*style*/\n`\n\n// Animation 넣기\nconst rotation = keyframes`\n  from {\n\ttransform:rotate(0deg);\n  }\n  to {\n\ttransform:rotate(180deg);\n  }\n`\nconst Div = styled.div`\n  /*style*/\n  animation: ${rotation} 1s linear;\n`\n\n//컴포넌트 안의 테그에 스타일 넣기\nconst Box = styled.div`\n  /*style*/\n  span {\n\t/*style*/\n\t&:hover{\n\t  /*style*/\n\t}\n  }\n  ${Component} {\n\t/*컴포넌트를 직접 넣을 수도 있음*/\n\t/*style*/\n  }\n`\n```\n## Themes and styled-components\n### `Props` 전달해주기\n하위 컴포넌트가 상위 컴포넌트로부터 `props`를 받을 수 있는것 처럼 `styled-components`도 `props`를 받아 활용 할 수 있다. \n```js\nconst Div = styled.div`\n  color: ${(props) => props.textColor};\n`\n...\n\n<Div textColor=\"black\" />\n```\n\n\n### 테마 적용하기\n\n`props`를 전달할 수 있다는 말은 스타일 요소가 동적으로 변할 수 있다는 말이다. 이를 이용하면 페이지의 테마 또한 동적으로 설정 할 수 있다. 먼저 `styled-components`의 `ThemeProvider`를 import해준 뒤, 사용 될 테마 설정을 해준다. 그리고 설정한 테마로 적용 될 컴포넌트 들을 감싸준다.\n```js\nimport {ThemeProvider} from \"styled-components\";\n\t...\n  const darkTheme = {\n    textColor: \"white\";,\n    backgroundColor: \"black\";\n    ...\n  }\n\n\t...\n\t<ThemeProvider theme={darkTheme}>\n  \t  <App />\n  \t<ThemeProvider />\n\t...\n```\n그럼 이제 `App` 컴포넌트와 그 하위 컴포넌트들의 `styled-components`는 `ThemeProvider`가 제공해 주는 `darkTheme`을 `prop`으로 받을 수 있게된다. 따라서 `App` 컴포넌트 안에서 `styled-components`를 이용하여 다음과 같이 사용 될 수 있다.\n```js\n// App.jsx 의 styled-components\nconst Text = styled.span`\n  color: ${(props) => props.theme.textColor};\n`\n```\n이를 이용하여 `lightTheme`등, 같은 속성명을 가지는 여러 테마들을 만들어 놓고 `ThemeProvider`에 `theme`으로 전달해주는 객체를 바꿔주면 쉽게 테마를 변경할 수 있다.",
		"category": "posts",
		"createdAt": 1681116241968,
		"id": "styled-component",
		"title": "Styled Component"
	},
	"time-ago": {
		"author": "",
		"body": "유튜브는 비디오 생성 날짜 대신 **'3주 전'** 이나 **'1개월 전'** 과 같이 비디오가 얼마 전에 생성되었는지 나타내 준다. 이 표시는 사실 서버로부터 생성된 날짜와 시간을 받아온다면 현재 시간을 기준으로 바꿔주는건 그렇게 어려운일은 아닐 것이다. 하지만 이와같은 귀찮은 일을 대신 해주는 1kb대의 가벼운 패키지가 있어 공식문서를 토대로 간단하게 소개한다.\n\n## TimeAgo\n#### 설치\n```js\n$ npm install react-time-ago javascript-time-ago --save\n```\n리액트 타임어고는 자바스크립트 타임어고에 의존적이라 두개 다 추가한다.\n\n#### 초기화\n타임어고는 아래와 같은 초기화가 필요하다.\n```js\nimport TimeAgo from 'javascript-time-ago'\n\nimport en from 'javascript-time-ago/locale/en.json'\nimport ru from 'javascript-time-ago/locale/ru.json'\n\nTimeAgo.addDefaultLocale(en)\nTimeAgo.addLocale(ru)\n```\n### 불러오기 & 사용하기\n그 뒤에 리액트 타임어고를 불러서 쓰면 된다.\n```js\nimport ReactTimeAgo from 'react-time-ago'\n<ReactTimeAgo date={publishedAt} />\n```\n다만 `date`에 들어가야할 데이터 형식은 `Date instance`여야 하므로 `new Date()`에 담아줘야 에러가 생기지 않는다.\n\n### 사용예시\n한국어도 지원하는데 한국어를 기준으로 사용 예시는 아래와 같다. \n```js\nimport TimeAgo from 'javascript-time-ago'\nimport ko from 'javascript-time-ago/locale/ko.json'\n\nimport ReactTimeAgo from 'react-time-ago'\n\nTimeAgo.addDefaultLocale(ko)\n// ...\n <ReactTimeAgo date={new Date(publishedAt)} />\n```\n`TimeAgo`와 언어설정인 `ko`를 불러와서 불러온 `TimeAgo`를 이용하여 기본 언어 설정을 한국어로 해준 뒤에, `ReactTimeAgo`를 불러와 컴포넌트처럼 쓰면 된다. 다만, `date` 속성에는 `Date instance`로 들어가야 하므로 사용 하는 자료형에 따라 `new Date()`를 이용하여 `date intance`로 바꿔줘야 할 소요가 생길 수 있다.\n\n이 외의 기능들이나 더 자세한 사항은 <a href='https://www.npmjs.com/package/react-time-ago'>공식문서</a>를 통해 확인 가능하다. ",
		"category": "posts",
		"createdAt": 1681116177781,
		"id": "time-ago",
		"tags": ["React"],
		"title": "Time Ago"
	},
	"usememo와-usecallback": {
		"author": "",
		"body": "`useCallbak`과 `useMemo`는 리액트 앱의 대표적인 성능개선 훅으로 리액트 앱의 과도한 리렌더링을 방지하여 앱의 성능을 향상시킨다. 작동 원리는 리액트 쿼리의 키와 같이 두 함수 모두 의존값을 가지는 배열을 하나 만들어 의존값이 변하지 않을때는 기존에 저장한 값을 사용하고 의존값이 바뀔 때에만 연산을 통해 값을 반환한다. \n```js\nconst memoizedCallback = useCallback(() => {\n  // 함수 로직\n}, [dependency]);\n```\n## useMemo \n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction calculateExpensiveValue(count) {\n  // 복잡한 연산 수행\n  return count * 10; // 예시를 위해 간단한 연산\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [otherValue, setOtherValue] = useState(0);\n\n  const expensiveValue = useMemo(() => calculateExpensiveValue(count), [count]);\n  //otherValue의 변경으로 컴포넌트가 다시 렌더링 되더라도 count는 계산되지 않고 값이 재사용됨.\n  return (\n    <div>\n      <p>Expensive Value: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Increase Count</button>\n      <button onClick={() => setOtherValue(otherValue + 1)}>Increase Other Value</button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n원래 컴포넌트 내의 상태(state)가 변하면 컴포넌트가 리렌더링 되면서 `expensiveValue`가 다시 계산되어야 한다. 하지만 위 예에서는 `expensiveValue`가 `useMemo`로 `count`의 변경에 의존해서만 계산되기 때문에 이전 값을 재사용 하기 때문에 계산이 복잡할수록 `useMemo`로 성능 향상을 기대할 수 있다. \n\n## useCallback\n`useMemo`를 사용하는 상황은 비교적 단순하다. 복잡한 연산을 필요로 하는 작업을 줄이는 방향으로 설계하면 이또한 좋은 방법이 되기 때문이다. 하지만 `useCallback`은 약간 사정이 다르다. `useCallback`은 로직의 재활용이 가능하게 해줘서 함수가 속한 컴포넌트가 리렌더링 될 때, 함수의 재선언을 방지해 주는 역할에 그치기 때문에 함수의 재선언 작업정도만 줄여주기 때문이다. \n따라서 `useCallback`을 사용할때에는 몇가지 상황을 고려할 수 있다.\n\n1. 자식 컴포넌트에 함수를 전달할 때: 부모 컴포넌트가 리렌더링될 때마다 새로운 함수 참조가 생성되어 자식 컴포넌트에 전달되면, 자식 컴포넌트도 불필요하게 리렌더링될 수 있다. 이런 경우 `useCallback`을 사용하여 함수 참조를 유지하면, 자식 컴포넌트의 불필요한 리렌더링을 방지할 수 있다.\n\n2. 빈번한 이벤트 처리: 빈번한 이벤트 처리, 예를 들어 스크롤 이벤트나 마우스 이동 이벤트 같은 경우, 매 이벤트 발생마다 새로운 함수가 생성되지 않도록 `useCallback`을 사용해 함수의 재생성을 줄일 수 있다.\n\n3. 메모이제이션된 자식 컴포넌트: `React.memo`를 사용하여 최적화된 자식 컴포넌트가 있고, 이 컴포넌트에 함수를 전달할 경우 `useCallback`을 사용하여 함수 참조를 유지함으로써, 불필요한 자식 컴포넌트의 리렌더링을 방지할 수 있다.\n\n",
		"category": "posts",
		"createdAt": 1681986632055,
		"id": "usememo와-usecallback",
		"tags": ["React"],
		"title": "useMemo와 useCallback"
	}
}
