{
	"loading-ui-and-streaming": {
		"author": "",
		"body": "app 디렉토리의 `loading.js`는 컨텐츠가 로드 되는 동안 서버의 로딩 상태를 먼저 렌더링 하게 도와주기 때문에 매우 빠른 FCP를 달성하도록 도와준다.\n\n![](https://velog.velcdn.com/images/latemarch/post/06e8ad55-8773-4d22-be73-c7d1b4a38699/image.png)\n\n로딩 UI를 사용하려면 적용하려는 페이지에 `loading.js`를 만들고 리액트18의 `<Suspense />`에 fallback으로 넘겨주는 걸로 족하다.\n![](https://velog.velcdn.com/images/latemarch/post/858f6c24-1a1c-4d00-82ca-fb4c5f5bd5fa/image.png)\n\n## Streaming with Suspense\n\nSSR은 아래의 단계적인 과정을 거쳐 렌더링 된다.\n\n1. 페이지에 필요한 모든 데이터를 서버로부터 받아옴.\n2. 서버는 페이지 표시를 위한 HTML을 파싱.\n3. 서버는 HTML, CSS, 그리고 JavaScript코드를 클라이언트에 전송.\n4. 클라이언트에서 HTML과 CSS를 이용해 비상호적인 요소들을 표시.\n5. 상호작용적인 유저 인터페이스에 hydration이 일어남.\n\n![](https://velog.velcdn.com/images/latemarch/post/e75cbf3b-f032-44aa-9c90-f2365ea64625/image.png)\n모든 단계들이 순차적으로 일어나기 떄문에 페이지 로딩이 길어질 수 있다. \nStreaming은 이런 하나의 과정을 여러개의 덩어리(chunk)로 쪼개서 병렬처리 할 수 있도록 도와준다. 이 기능은 페이지를 구분하여 데이터 패치를 기다리지않고 먼저 렌더링 가능한 부분을 표시할 수 있게 도와준다.\n![](https://velog.velcdn.com/images/latemarch/post/f8fbd0c6-9ad8-4796-9f67-a331bfb215ec/image.png)\n\n이 기능을 사용하면 `<Suspense/>`의 데이터 패칭과 렌더링을 기다리지 않기 때문에(fallback으로 전달한 `loading.js`가 렌더링되므로) `layout`과 같이 서버 데이터에 의존하지 않는 정적인 정보를 즉각적으로 표시 할 수 있다. 즉 리액트 컴포넌트들의 데이터 패칭과 렌더링을 병렬 수행 할 수 있기 때문에, 전체적인 페이지 로드 시간을 줄이는 결과를 가져온다. \n![](https://velog.velcdn.com/images/latemarch/post/d2e3c051-0ea2-4109-820c-263a95671b53/image.png)\n\n\n ## SEO\n본질적으로 페이지는 서버에서 렌더링 되고 클라이언트에 전달되는데 이 과정에서 메타 데이터 생성은 Streaming이 완료될 때까지 기다리고, 그 후에 페이지 UI를 `<head>` 태그와 함께 클라이언트에 전송(Streaming)한다. 따라서 전송된 응답의 첫 부분에 `<head>`태그가 포함되고 SEO측면에서 SSR의 이점을 그대로 가지고 올 수 있다.",
		"category": "posts",
		"createdAt": 1686837489071,
		"description": "큰 데이터 패칭이 요구되는 SSR페이지의 TTI가 커지는 문제가 있다. 이 때, Next.js의 Streaming기능은 순차적으로 진행되는 렌더링 과정을 여러개의 덩어리로 쪼개서 병렬로 처리할 수 있게 도와준다. 또한 메타 데이터생성은 Streaming을 기다리므로 SEO에도 영향을 주지 않는다.",
		"id": "loading-ui-and-streaming",
		"tags": ["Nextjs"],
		"title": "Loading UI and Streaming"
	},
	"nextjsapprouter": {
		"author": "",
		"body": "리액트18부터, 서버 컴포넌트를 지원 하면서 next.js에서 서버 컴포넌트와 클라이언트 컴포넌트를 섞어 앱을 구성하여 기존 csr이나 ssr보다 더 나은 성능으로 렌더링 할 수 있게 한다. 이 전에는 페이지 단위로 csr, ssr이 정해졌지만 이제는 컴포넌트 단위로 렌더링 방식을 결정할 수 있게 된 것이다.\n![](https://velog.velcdn.com/images/latemarch/post/0a29a51b-4a60-4c10-8c81-640843504c1e/image.png)\n\n컴포넌트 단위로 렌더링 방식을 정할 수 있다보니 위 그림 처럼 서버 컴포넌트 안에 클라이언트 컴포넌트를 넣어서, 상호작용이 필요한 컴포넌트들만 csr로 넘겨줄 수 있다.\n\n## 서버 컴포넌트의 이점\n\n서버 컴포넌트를 사용하면 [이전 글](https://latemarch.vercel.app/posts/getserversideprops)에서 설명 했던 것과 같이 렌더링과 SEO에서 이점이 있다. 또한 Next.js에서 제공하는 App Router의 `fetch`함수를 사용하면, 데이터를 서버에서 캐싱하고 revalidate하는 기능들을 사용하며 데이터를 더 효율적으로 관리 할 수 있다. 또한 컴포넌트 코드를 서버에서 관리하기 때문에 번들이 cacheable, predictable해지며 유저와 상호작용해야하는 자바 스크립트 코드가 추가 되지 않는 한, 컴포넌트가 커지더라도 앱 크기가 커지지 않는 장점이 있다. \n\n## 클라이언트 컴포넌트 사용하기\nNext.js의 App Router를 사용하면 모든 컴포넌트가 서버 컴포넌트로 기본설정 되기 때문에 클라이언트 컴포넌트를 사용하려면 별도의 명시가 필요하다.\n\n```js\n'use client'\n \nimport { useState } from 'react'\n \nexport default function Counter() {\n  const [count, setCount] = useState(0)\n \n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n```\n임포트 위에 `'use client'`를 입력하면 컴포넌트를 간단하게 클라이언트 컴포넌트로 사용할 수 있다. (클라이언트 컴포넌트더라도 react에서와 달리 서버에서 렌더링 된 상태로 클라이언트에 넘어간 뒤 hydration이 일어난다.)\n\n## Server Components inside Client Componenrs\n\n`'use client'`로 컴포넌트를 클라이언트 컴포넌트로 만들 고 난뒤, 아래에 임포트 하는 모든 컴포넌트들은 클라이언트 컴포넌트로 간주 된다. \n![](https://velog.velcdn.com/images/latemarch/post/2d165677-079c-44a2-abbc-8e667e6e52ca/image.png)\n\n이러한 이유 때문에 Next.js는 `'use client'`아래에 서버 컴포넌트를 임포트 하는것을 지원하지 않는다. \n서버 컴포넌트를 클라이언트 컴포넌트 안에서 보여주고 싶다면 클라이언트 컴포넌트에 prop으로 넘겨 줘야 한다.\n```js\n'use client'\n \nimport { useState } from 'react'\n \nexport default function ExampleClientComponent({\n  children, // server component\n}: {\n  children: React.ReactNode\n}) {\n  const [count, setCount] = useState(0)\n \n  return (\n    <>\n      <button onClick={() => setCount(count + 1)}>{count}</button>\n \n      {children} //server component\n    </>\n  )\n}\n```\n단, 상위의 서버 클라이언트에서는 하위에 표시할 서버 컴포넌트와 클라이언트 컴포넌트 모두 임포트 하여 사용할 수 있다.\n```js\n// This pattern works:\n// You can pass a Server Component as a child or prop of a\n// Client Component.\nimport ExampleClientComponent from './example-client-component'\nimport ExampleServerComponent from './example-server-component'\n \n// Pages in Next.js are Server Components by default\nexport default function Page() {\n  return (\n    <ExampleClientComponent>\n      <ExampleServerComponent />\n    </ExampleClientComponent>\n  )\n}\n```\n사실 위와 같이 `children` prop으로 넘겨주는 패턴은 리액트에서도 흔히 활용되는 패턴이며 layouts과 pages를 구성하면서 이미 경험했던 방식이다. 또한 위와 같은 방식을 사용하면 부모 (client)컴포넌트의 역할은 오직 넘겨받은`children`을 적당한 위치에 위치 시키는 일 뿐이므로 **컴포넌트 간 독립성을 유지할 수 있게 한다.** ",
		"category": "posts",
		"createdAt": 1686452814629,
		"description": "리액트18부터, 서버 컴포넌트를 지원하면서 Next.js 13부터 서버 컴포넌트와 클라이언트 컴포넌트를 섞어서 페이지를 구성할 수 있게 됐다. 기존의 페이지 단위로 결정됐던 SSR, CSR방식이 더 세분화 되어 더 나은 성능을 기대할 수 있게 됐다.",
		"id": "nextjsapprouter",
		"tags": ["Nextjs"],
		"title": "Next.js App Router"
	},

	"closure": {
		"author": "",
		"description": "Closure는 함수가 접근하여 수정 변경할 수 있는 변수들이 속한 영역들을 가르킨다. 이는 렉시컬 환경과 밀접한 관련이 있으며 렉시컬 환경을 이해하면 클로저는 쉽게 이해할 수 있다.",
		"body": "## Closure\n자바스크립트 함수는 함수 외부 변수에 접근하여 수정 변경이 가능한데 이 때, 수정가능한 변수가 담긴 렉시컬 환경(외부)의 범위를 클로저라고 한다. 클로저는 또한 외부 변수를 기억하고 그 변수에 접근할 수 있는 함수를 일컫기도 한다.  \n\n## Lexical Environment\n자바스크립트에서 실행중인 함수, 코드블록, 스크립트 전체는 렉시컬 환경(Lexical Environment)을 갖는다. 렉시컬 환경은 두 부분으로 구성되는데 하나는 코드 블록 내부를 표현하는 환경 레코드(Environment Record)로, 모든 지역변수의 프로퍼티를 갖고있고, 외부 렉시컬 환경(Outer Lexical Environment)는 외부 렉시컬 환경에 대한 참조를 담고있다. \n따라서 변수는 환경 레코드의 프로퍼티라고 볼 수 있다. 이 때문에 코드 블럭 내부의 변수를 외부 렉시컬 환경에서 불러올 수 없는 것이다. (지역 변수는 전역 환경 레코드에 프로퍼티가 아니며 외부 렉시컬 환경에도 포함되지 않기 때문에 전역 환경에서 지역변수를 불러 올 수 없다.) 다만, 블럭안에서 외부환경의 변수는 불러오는 것은 가능한데, 그 이유는 해당 렉시컬 레코드에서 변수를 찾지 못하면 외부 렉시컬 환경(Outer Lexical Environment)에서 그 변수를 찾으려 하고, 더이상의 외부 렉시컬 환경이 없을 때까지 반복되기 때문이다.\n\n## 렉시컬 환경과 함수\n그런데 이 특성은 함수의 불러올 수 있다는 특징과 만나 흥미로운 결과를 만든다. 함수는 선언될 자신이 선언된 위치의 렉시컬 환경을 `[[Environment]]`객체에 저장하게 된다. 그 뒤 함수가 실행되면 자신의 렉시컬 환경을 갖게 되는데, 특이한 점은 함수가 어디에서 실행 됐던, 자신이 선언된 위치의 렉시컬 환경을 `[[Environment]]`에 저장하고 있기 때문에 함수가 실행중인 위치와 전혀 상관없는 다른 위치의 렉시컬 환경에 영향을 받게 되는 것이다. \n```js\nfunction makeCounter()\n  let count = 0;\n\n  return function(){\n    return ++count;\n  }\n}\n\nlet counter = makeCounter();\n```\n위 상황에서 `return ++count;`의 한줄짜리 함수는 선언 될 때, `[[Environment]]`객체에 그 위체 대한 렉시컬 환경을 담게 된다. 이 후, `makeCounter`에 의해 만들어진 `counter`가 만들어 질 때, 함수의 렉시컬 환경을 갖게 된다. 따라서 원칙적으로 전역 환경에서 만들어진 `counter`함수는 함수 내의 `count`변수(`makeCounter`의 환결 레코드의 프로퍼티)에 접근할 수 없지만 `makeCounter`가 반환한 함수로 만들어진 `counter`함수는 `[[Environment]]`객체에 `makeCounter`의 렉시컬 환경을 담고 있으므로 `makeCounter`의 환경 레코드의 속성인 변수 `count`에 접근하며 변경할 수 있게 된다. \n\n\n## 화살표함수 \n화살표 함수가 일반 함수랑 다른점은 environment record에서 온다. 화살표함수의 환경레코드에는 일반 함수의 환경레코드와는 다르게 this, arguments object, super, new.target이 없다. \n\n### `arguments` 객체\n일반 함수는 전달인자를 받을때 자신만의 arguments 객체를 만들어 환경 레코드에 저장하는데 반해 화살표함수는 가진만의 arguments 객체를 가지지 못하고 외부 arguments 객체에 접근한다. 이때문에 아래와 같은 일이 생긴다.\n```js\nfunction myFunction() {\n  let arrowFunction = () => {\n    console.log(arguments);\n  };\n\n  arrowFunction(1, 2, 3);\n}\n\nmyFunction(4, 5, 6); // Output: [object Arguments] { 0: 1, 1: 2, 2: 3 }\n```\n화살표 함수의 logs가 가르키는 `arguments` 객체는 자신의 환경 레코드의 객체가 아닌 부모 렉시컬 환경에서 가지고 와야한다. 여기서 부모 렉시컬 환경은 `myFunction`의 렉시컬 환경이고, `myFunction`은 `arrowFunction`과 달리 환경 레코드에 자신만의 `arguments`객체를 가지므로 `arrowFunction`은 `myFunction`의 `arguments`객체에 접근하게 되는 것이다.\n\n### `this`\n 선언식으로 만들어진 매소드의 `this`는 함수가 불려진 객체를 나타낸다. \n```js\nlet myObject = {\n  prop: 'Hello',\n  myFunction: function() {\n    console.log(this.prop);\n  }\n};\n\nmyObject.myFunction(); // Output: 'Hello'\n```\n위 예제에서 `myObject`객체 안에 선언된 `myFunction`의 `this`는 `myFunction` 매소드가 호출될 때의 객체를 가르키게 된다. 하지만 화살표 함수로 선언된 매소드는 자신만의 `this`가 없다. 대신 화살표 함수를 감싸고 있는 함수의 `this`를 차용한다.\n```js\nlet user = {\n  firstName: \"보라\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // 보라\n```\n위에서 `arrow` 함수 안의 `this`는 `sayHi`함수의 `this`가 가르키는 객체를 사용한다. \n#### 객체 안의 화살표 함수.\n```js\nlet myObject = {\n  prop: 'Hello',\n  regularFunction: function() {\n    console.log(this.prop);\n  },\n  arrowFunction: () => {\n    console.log(this.prop);\n  }\n};\n\nmyObject.regularFunction(); // Output: 'Hello'\nmyObject.arrowFunction(); // Output: undefined\n```\n객체의 환경 레코드에는 `this`가 없다.\n#### 함수안의 객체안의 화살표 함수.\n```js\nobj = {\n  name: 'kim'\n  myFunction() {\n    let myObject = {\n      prop: 'Hello',\n      arrowFunction: () => {\n        console.log(this.name);\n      }\n    };\n\n  myObject.arrowFunction();\n  }\n}\n\nmyFunction(); // Output: kim\n```\n화살표 함수를 감싸는 `myFunction`함수의 `this`를 참조함.\n## Scope\n함수의 스코프란 함수가 접근가능한 환경레코드의 집합이라고 할 수 있다. 따라서 스코프는 렉시컬환경과는 약간 다른 개념이다. 위에서 설명 했듯이 함수가 선언될 때, 렉시컬환경의 범위는 내부 환경을 대변하는 환경레코드와 외부렉시컬환경의 참조로 이뤄지지만 만약 함수가 외부 렉시컬환경에서도 변수를 찾기 못하면 함수는 외부렉시컬환경의 외부렉시컬환경으로 변수를 찾아 나서기 때문이다. 이와같은 이유 때문에 스코프의 범위는 함수가 갖는 렉시컬환경 그 이상으로 확대된다.\n",
		"category": "posts",
		"createdAt": 1681115991498,
		"id": "closure",
		"tags": ["ES"],
		"title": "Closure"
	},
	"getserversideprops": {
		"author": "",
		"description": "Next.js에서는 서버사이드 렌더링(SSR)과 빌드 시점에 정적 페이지 렌더링(SSG)를 지원해 클라이언트 사이드 렌더링(CSR)의 단점인 TTFB를 크게 줄일 수 있다. 여기서는 Pages Router를 이용한 프로젝트에서 SSR을 이용하는 방법을 소개한다. ",
		"body": "`getServerSideProps`는 Next.js에서 제공하는 서버 사이드 렌더링(SSR)을 위한 함수이다. 이 함수는 각 요청에 대해 서버에서 실행되며, 페이지에 필요한 데이터를 가져와 페이지의 props를 통해 컴포넌트로 전달한다. \n\n## 렌더링\n보통 유저는 페이지가 자바스크립트 로드까지 끝난 뒤 자바스크립트를 통해 요청한 데이터를 기다린 후 데이터 fetch가 끝나면 페이지를 온전히 받을 수 있게 된다. 하지만 `getServerSideProps`로 데이터를 서버 측에서 요청한 데이터로 받을 수 있다면, 자바스크립트 로드를 기다리지 않는 다는 이점 하나만으로도 TTFB를 크게 줄일 수 있다. \n\n다음은 getServerSideProps의 기본적인 사용 방법이다.\n```js\nexport async function getStaticProps() {\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n\n  if (!data) {\n    return {\n      notFound: true,\n    }\n  }\n\n  return {\n    props: { data }, \n  }\n}\n```\n\ngetServerSideProps는 페이지의 초기 로딩 시에만 실행되며, 클라이언트 사이드 라우팅에서는 실행되지 않는다. 그러나 매 요청마다 서버에서 실행되므로, 트래픽이 많은 웹 사이트의 경우 서버에 부담을 줄 수 있다.\n## SEO\n\n클라이언트 사이드에서 API를 요청하는 경우, 크롤러가 페이지를 방문했을 때 데이터를 로딩하는 JavaScript 코드만 볼 수 있다. 이 경우 크롤러가 데이터를 인식하는 데 어려움이 있을 수 있다.\n반면에 서버 사이드에서 API를 요청하면, 크롤러가 방문했을 때 이미 완성된 HTML을 보게 되므로, SEO에 유리하다.\n\n\n## 다른 방법\nNext.js는 또한 getStaticProps라는 다른 데이터 가져오기 함수도 제공하는데, 이는 정적 생성(Static Generation, SSG)을 위한 것이다. getServerSideProps와 다르게 getStaticProps는 빌드 시에만 실행되므로, 요청마다 실행되지 않는다. 때문에, 가능한 경우 getStaticProps를 사용하는 것이 효율적일 수 있습니다.",
		"category": "posts",
		"createdAt": 1684902580873,
		"id": "getserversideprops",
		"tags": ["ETC"],
		"title": "getServerSideProps"
	},
	"global-snippet-setting": {
		"author": "",
		"description": "함수형 컴포넌트를 만들기 위해 기본 코드를 치는 일과 같이 반복적이고 정해진 작업들은 코딩을 하면서 여간 귀찮은 작업이 아닐 수 없다. 이런 작업들을 단축키 처럼 지정해서 빠르게 작업할 수 있는 방법이 있다.",
		"body": "snippet으로 컴포넌트 등 자주 쓰는 코드 템플릿을 불러 올 수 있다.![](https://velog.velcdn.com/images/latemarch/post/54997bb5-088c-4aec-adda-936d5e6f9afd/image.png)\n가령 위와 같이 리액트 함수 컴포넌트를 만들 수 있는 단축 구문을 `rfc`로 명명하여 snippets에 설정해 놓으면 파일명을 기반으로 빈 리액트 컴포넌트를 만들어 준다.\n![](https://velog.velcdn.com/images/latemarch/post/95396407-79d6-43c9-b00e-53e3f0be18ad/image.png)\n사용법은 간단하다. vscode의 커맨트 팔레트에 `snippets`로 들어와 `global.code-snippets`를 선택해 준다. 파일이 없으면 생성한다.\n\n![](https://velog.velcdn.com/images/latemarch/post/62daa918-6c6c-4c88-bd5b-29f6eb350539/image.png)\n![](https://velog.velcdn.com/images/latemarch/post/9fc3213f-f1b5-4a23-a287-6293a2fcc426/image.png)\n그리고 아래의 코드를 파일에 써준다.\n```js\n{\n\t\"reactFunction\": {\n\t\t\"prefix\": \"rfc\",\n\t\t\"body\": \"import React from 'react';\\n\\nexport default function ${1:${TM_FILENAME_BASE}}(){\\n\\treturn (\\n\\t\\t<div>\\n\\n\\t\\t</div>\\n)}\",\n\t\t\"description\": \"Creates a React Function component\"\n\t}\n}\n```\n이제 `prefix`의 값이 `body`를 작성하는 단축 구문이 된다. ",
		"category": "posts",
		"createdAt": 1681116095027,
		"id": "global-snippet-setting",
		"tags": ["ETC"],
		"title": "Global snippet setting"
	},
	"react-query": {
		"author": "",
		"description": "Redux와 같은 상태관리 툴은 서버에서 오는 데이터를 관리하기엔 다소 비효율 적인 면이 있다. 다른곳(서버)에서 관리 되는 정보파 정보의 변화를 서버의 도움 없이 파악할 수 없어, 효율적인 자원 관리를 위해 swr이나 react-query와 같은 도구가 필요하다.",
		"body": "## React Query\n컴포넌트를 사용해 중복된 요소들을 쉽게 표현할 수 있지만, 컴포넌트는 자료의 재사용이 목적이 아니므로 컴포넌트에 서버에 api 요청을 하는 로직이 추가 되어 있는 경우, 개발자의 의도와는 다르게 과도한 요청이 일어날 수 있다. 이런 문제는 Query를 사용하여 비교적 쉽게 해결할 수 있다.   \n![](https://velog.velcdn.com/images/latemarch/post/865bfa34-1eb9-45a6-8c27-31ce64ef09bb/image.png)\n\n위 그림은 Query의 메인페이지 인데 그림에서 볼 수 있듯이 쿼리는 상태관리와 페칭, 비동기 코드들을 관리 한다. 사용자들은 쿼리를 주로 페칭, 캐싱, 비동기와 서버상태의 업데이트를 위해 사용한다. 쿼리를 이용하면 컴포넌트의 중복된 페치 요청을 막을 수 있는데 이는 쿼리가 요청한 자료를 캐싱하여 재요청 여부를 결정하기 때문이다. \n\n## Quick Start\n\n쿼리의 사용법은 기타 상태관리 library와 비슷하다.\n```js\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\n// Create a client\nconst queryClient = new QueryClient()\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n```\n`queryClient`를 만들어 주고, 이를 적용될 범위에 부모요소로 감싸줘 스코프 설정을 한다. 이렇게 되면 일단 쿼리를 사용할 준비는 끝난다. 그 뒤 쿼리를 사용할 컴포넌트에서 `useQuery`를 사용해 페치해준다.\n```js\nconst {isLoading, error, data} = useQuery(['data'], ftn)\n```\n`useQuery`는 많은 정보를 제공하지만 여기서는 로딩중인지, 에러가 났는지, 그리고 데이터를 받아온다. `useQuery`함수에는 배열 형태인 키와 페칭 함수를 전달인자로 받는다. 쿼리는 이제부터 페치한 데이터를 키를 기준으로 관리하게 된다. 동일 키를 가진 데이터에 대한 페치요청이 다시 발생하게 되면, 캐시된 데이터를 우선적으로 가져오는 방식이라 생각하면 된다.  \n\n## Important Defaults\n리액트 쿼리가 캐싱과 페칭을 관리해주는것은 사용자에게 굉장히 유익한 경험을 준다. 하지만 이런 경우 '어떤 키'로 페칭한 데이터에 대한 리페칭 이슈가 있을 수 있다. \n\n- [Query instances via `useQuery` or `useInfiniteQuery` by default consider cached data as stale.](https://tanstack.com/query/latest/docs/react/guides/important-defaults)\n\n한번 페칭이 일어난 데이터는 그 즉시 오래된(staled) 데이터로 간주되기 때문에 다음 요청에 바로 페칭이 일어나게 된다. (동일 렌더링에서는 한번만 요청한다.) 때문에 사용자가 의도한대로 선능 개선이 일어나지 않을 수 있으며, 상황에 따라 쿼리를 사용하기 전보다도 더 많은 api요청이 발생할 수도 있다. 따라서 페칭에 대한 관리도 사용자의 몫이 된다. 이를 위한 방법은 공식문서에 잘 나와있지만 여기에서는 가장 간단한 방법인 오래된(staled) 데이터로 간주하는 최소 시간을 설정해 주는 방법만 간단하게 소개한다.\n```js\nconst {isLoading, error, data} = useQuery(['data'], ftn, {staleTime:1000*60*1})\n```\n위와 같이 페칭 함수 뒤에 객체 형태로 조건을 넘겨줄 수 있는데, 쿼리는 이 조건에 따라 페칭 여부를 판단하게 된다.\n\n## 리액트 쿼리와 상태관리\n리액트는 그 자체적으로 데이터 페칭 기능을 제공해 주지 않기 때문에, 개발자가 직접 서버의 데이터를 가지고와 관리하는 방법을 강구해한다. 이는 보통 서버에서 가지고 온 데이터를 일반적인 상태관리 툴과 함께 사용하는 방법을 이용한다. 하지만 서버 데이터는 외부 데이터를 가지고 오는 과정을 거치므로 리액트 상태와는 달리 일반적인 상태관리 툴로 다루기에 적합하지 않다. 따라서 실시간으로 업데이트 되는 서버 상태를 클라이언트와 효과적으로 동기화 하기 위해 Query를 이용한다.\n\n공식 문서에 나온 방법과 같이 react Query 또한 다른 상태관리도구들과 같이 스코프 설정을 해서 서버로부터 가지고 온 데이터를 제공할 컴포넌트들을 정한다.\n\n```js\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n```\n따라서 <QueryClientProvier>로 스코프 설정 안에 들어있는 컴포넌트들은 query가 받아온 데이터를 공유하게 된다. 이같은 이유로 원한다면 리액트 상태들도 Query의 스코프 설정안에서 공유되어 Query를 전역상태도구로 사용할 수도 있지만 react Query는 서버 상태를 관리하는 목적으로 최적화 됐기 때문에 그 용도에 맞지 않다.\nreact Query는 키를 통해 데이터를 관리하게 된다.\n```js\nimport { getTodos } from '../my-api'\nconst query = useQuery('todos', getTodos)\n```\n위 예시에서 query에 담긴 데이터는 'todos'라는 키와 함께 캐시에 저장되어 관리된다. 키와 함께 효율적인 리프레시 설정하여 성능 향상을 가지고 올 수 있지만 반대로 캐시된 데이터 때문에 오히려 데이터 동기화 문제가 생길 수 있다.\n또한 react Query는 전역상태를 관리하는 목적으로 만들어 진게 아니기 때문에 Redux의 reducer나 action과 같은 전역상태 관리에 편의를 주는 기능들이 없다. 또한 서버 데이터 관리를 목적으로 만든만큼 전역상태를 관리할 때 성능측면에서도 좋지 않다고 하니 굳이 react Query를 고집하여 전역상태를 관리할 필요는 없다.\n\n## 쿼리 무효화 전략\n앞서 query에 담긴 데이터가 특정 키와 함께 캐시에 저장되어 데이터 동기화 문제를 야기한다고 했다. 이 점을 보완하기 위해서 특정 키와 일치하는 모든 쿼리를 무효화 한다. 무효화된 쿼리는 캐시에서 지워지지는 않지만 무효화된 쿼리를 대신할 새로운 쿼리를 구성하기 위해 리페치 과정이 유도되며 이 과정에서 리액트 컴포넌트의 적절한 리렌더링이 일어난다.\n\nuseQuery가 데이터를 가지고 오는 일은 하는 hook이라면, 서버 데이터에 변화를 주는 일에는 useMutation이 있다. 목적이 명확한 이 두 훅을 사용하면 앱에서 데이터를 가지고 오거나 변화를 주는 코드를 구분하기 쉽게하고 코드 유지보수를 쉽게 만들어준다. 또한 useMutation의 콜백함수인 onSuccess는 mutation이 성공적으로 이뤄졌을 때 호출되는데 이 콜백함수를 이용해 특정 queiry의 키를 무효화 할 수 있다. invalidateQueries를 사용하면 서버에서 데이터가 변경되었을 때 해당 변경 사항을 반영하도록 클라이언트 캐시를 새로 고칠 수 있다. 예를 들어, 데이터를 업데이트하는 뮤테이션을 실행한 후 해당 데이터에 대한 쿼리를 무효화하면 변경 사항이 반영된 새로운 데이터를 가져올 수 있다.\n\n## Query Custom Hook\n여느 훅과 같이 Query hook으로 같은 작업은 여러 컴포넌트에서 실행하는 경우가 있다. 특히 Query hook 같은 경우는 서버에서 데이터를 가지고 오는 작업이므로 react hooks보다 클라이언트 여러곳에서 더 빈번하게 사용되는 경우가 흔하다. 또한 Query hook은 위에서 본것과 같이 key를 통해 data fetching을 결정하므로 key를 관리하는 측면에서도 여러 곳에서 반복되어 사용되는 Query hook을 하나로 관리할 필요가 있다.",
		"category": "posts",
		"createdAt": 1681115765495,
		"id": "react-query",
		"tags": ["React"],
		"title": "React Query"
	},
	"react-redux": {
		"author": "",
		"description": "상태관리 툴인 Redux는 클라이언트 전반에 걸쳐 사용되거나 변경되어야 하는 상태들을 관리한다. 컴포넌트끼리 전달하는 방법에는 유지보수 측면에서도 좋지 않고 앱을 지나치에 복잡하게 만들기 때문이다. 상태 관리 툴은 러닝커브를 극복하면 매우 편리한 도구지만 오버헤드와 보일러플레이트가 존재하기 때문에 필요한 부분에서만 사용되어야 한다.",
		"body": "리덕스는 상태관리툴로 전역에 걸쳐 접근해야 하는 상태를 관리한다. 리덕스는 자바스크립트 환경에서 작동하기 때문에 리액트는 물론이고 vue, react native, angular와 같은 기타 프레임워크에서도 작동한다. 일단 자바스크립트에서의 리덕스의 기본 동작은 간단하다.\n## Javascript와 Redux\n```js\nimport {createStore} from 'redux'\n\nconst reducer = (state = 0) =>{\n  return state\n\n}\nconst store = createStore(reducer)\n```\n리덕스를 불러와 컨테이너(`store`)를 하나 만든다. 저장소를 만들때 함수를 하나 전달해 주는데 이 함수를 reducer 라고 부른다. 이 함수는 코드 시작과 함께 `store`에 저장된 `state`를 초기화 하면서 시작하고 이후에 `state`는 함수 `reducer`를 통해 수정(modify)된다.\n\n### 수정하기\n만들어진 컨테이너의 `state`를 변경하는 방법은 `action`이라는 객체를이용하는 것인데 이 객체를 사용하기 위에서는 `action` 객체를 `ruducer`함수에 넘겨주어야한다. `action` 객체는 일어날 일을 서술하고 있는 객체로, 함수가 아님에 주의해야한다. 아래애서 [공식문서](https://ko.redux.js.org/introduction/getting-started/)에 나오는 예제를 소개한다.\n```js\nimport {createStore} from 'redux'\n\nconst reducer = (state = 0, action) =>{\n  if (action.type === 'INCREMENT')\n    return state+1\n  return state\n\n}\nconst store = createStore(reducer)\nstore.dispatch({ type: 'INCREMENT' })\n```\n이제 우리의 첫번째 예제의 `reducer`함수에 `action`이라는 객체가 전달인자로 추가되었다. 이 `action`이라고 불리우는 객체는 위에서 설명 했듯이 무엇이 일어날지에 대한 서술을 담은 객체이다. `action`객체는 컨테이너 내장함수인 `dispatch`에 의해 `reducer`함수로 전달될 수 있다. 이제 `reducer`함수는 전달인자로 받은 객체의 속성을 토대로 `reducer`함 수 안에서 `state`를 변경할 수 있다면 기본적인 `redux`의 사용법을 익힌것이나 다름 없다.\n\n### state 적용하기\n```js\nimport {createStore} from 'redux'\n\nconst num = document.getElementById(\"number\")\n\nconst reducer = (state = 0, action) =>{\n  if (action.type === 'INCREMENT')\n    return state+1\n  return state\n\n}\nconst store = createStore(reducer)\nstore.dispatch({ type: 'INCREMENT' })\n\nstore.subscribe(()=> num.innerText = store.getState());\n```\n`state`는 위와 같이 `store`의 내장함수 `subscripbe`에 의해 `state`가 변경 될때마다 DOM으로 반영 될 수 있다. \n여기까지 자바스크립트에서 리덕스가 어떻게 작동 되는지 보았다. 요약하자면 \n\n1. 전역적으로 관리하고 싶은 `state`를 하나 만들어서 \n2. `reducer`를 통해 관리하는데 \n3. `action`이라는 객체에는 `reducer`가 `state`관리하는 방법이 담겨있다.\n4. 그리고 이 모든 것은 `store`에 담겨 있다.\n\n자바스크립트에서는 위와 같은 일들이 피교적 간단하게 해결되었지만 리엑트에선 리액트의 컴포넌트데이터 흐름이 단방향이라는 특징 때문에 간단하게 진행되지만은 않는다. 당장 생각해 봐도 리덕스가 리액트에서 어떻게 props drilling을 해결할지에 대한 이미지가 떠오르지 않는다. 당장 `store`와 `reducer`만이라도 각 컴포넌트에 전달되어야 할것 처럼 보이기 때문에 상태 끌어올리기만도 못해 보이기 때문이다. \n## React와 Redux\n### 그럼에도 원리는 같다.\n하지만 기본적인 구동방식은 동일하다. `state`는 `action`객체가 명명한 대로 `reducer`에 의해 수정되며 이 수정과정 또한 `dispatch`를 통해 수행된다. 또한 이런 상태, 객체, 함수들은 `slice`라는 함수에 묶여있어 `slice`내의 상태는 같은 `slice`내에 있는 `reducer`에 의해서만 변경되는 베타적인 성격을 가진다. 또한 이 `slice`는 `configureStore()`통해 생성된 `store`객체에 의해 관리될 수 있는데, `configureStore()`를 통해 생성된 `store`는 위의 상태,객체,함수등을 담는 용도 외에 리덕스에서 제공하는 여러 기능들을 담고있기도 하여 `configureStore()`이용해 리덕스 스토어를 관리하는 것이 공식문서에서 권장되고 있다. 요약하자면 리액트에서도 리덕스가 작동하는 방식은 결국 같다.\n\n1. 전역적으로 관리하고 싶은 `state`를 하나 만들고 \n2. `reducer`를 통해 관리하는데 \n3. `action`이라는 객체가 관리하는 명세서 같은 역할을 한다.\n3-1. 이 모든것은 `slice`함수에 베타적으로 작동한다.\n4. 그리고 이 모든 것은 (`configureStore()`에 의해 만들어진)`store`에 의해 묶여있다.\n\n### Redux Toolkit을 이용한 React환경에서 Redux구현\n이제부터 React에서 Redux를 쓰는 방법을 소개하고자 한다. 단계별로 진행 되는 과정에서 반드시 아래의 방법을 따르지 않아도 된다. 하지만 결국 `reducer`를 만들어 `state`를 관리한다는 점에서는 같다. \n\n1. `configureStore`를 이용해 빈 `sotre`를 만든다.\n2. `createSlice`에 초기상태와 `action`을 작성해 `reducer`에 넣어준다.\n3. `reducer`를 1번에서 만든 `store`에 넣어준다.\n4. 이제 리액트 컴포넌트에서 `useSelector`를 이용해 `state`에 접근하고, `useDispatch`를 이용해 변경할 수있다.\n\n상태관리 툴이 항상 그렇듯이 리덕스도 provider로 리덕스 컨테이너가 적용될 범위를 감싸줘야한다. 한번 만들어진 컨테이너(`store`)는 `Provider`를 통해 적정 컴포넌트에 접근 가능하게 만들어 줄 수 있다. 먼저 `store`를 만든다.\n```js\nimport { configureStore } from '@reduxjs/toolkit'\n\nexport defualt configureStore({\n  reducer:{}\n})\n```\n이 `store`에는 `state`와 `action`을 담은 `reducer`가 추가되어야 하지만 일단은 빈 컨테이너로 놔두고 차차 진행해보기로 한다. 빈 컨테이너를 만들었다면 비록 비었지만 `적당한 컴포넌트`들이 이 컨테이너에 접근할 수 있게 하기위해 `Provider`를 이용해 `적당한 컴포넌트`들을 감싸준다.\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n//./app/store 파일에 리덕스 store를 만들어둠\nimport store from './app/store' \nimport { Provider } from 'react-redux'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n이렇게 앱을 감싸주게 되면 `App`과 그 하위 컴포넌트들은 이제 리덕스가 관리하는 상태에 접근하고 변경할 수 있게 된다. 컨테이너를 만들었으니, 이제 컨테이너를 채워보자. 위에서 설명했듯이 컨테이너는`reducer`를 담고있고 `reducer`는 `action`객체와 `state`를 담고있다.  \n\n### Redux State Slice\n`Slice`를 작성할 파일 하나를 추가하자. \n```js\nimport { createSlice } from '@reduxjs/toolkit'\n\nexport cont conterSlice = createSlice({\n  //state를 정의한다. 이제 counter라는 이름의 state는 state.value=0 으로 초기화 되었다. \n  name: 'counter'\n  initialState:{\n  \tvalue:0\n  \t//qty:0 와같이 추가로 속성을 더해주면 2개의 state를 하나의 slice로 관리하게 된다.\n    //이와같은 방법으로 여러개의 state를 하나의 slice에 묶어 관리할 수 있다.\n  },\n  reducer{\n    increment: state => {\n      state.value+=1                              \n    },\n    decrement: state => {\n      state.value-=1                              \n    }\n    incrementByAmount: (state, action) => {\n      state.value += action.payload\n    }\n  }\n})\n\n// createSlice()의 인스턴스인 couterSlice는 action을 자동으로 생성한다.\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\nexport default counterSlice.reducer\n```\n이제 언뜻 보면 `slice`안에 `state`와 `action`을 담아준것 처럼 보이지만 사실 `slice`는`increment`와 같은 코드를 `action`으로 만들고 \"초기\"`state`를 받아 `reducer`를 \"만들어\"주는 역할을 한다. 이후에 `state`가 `reducer`에 의해 변경된다고 하더라도 `slice`내의 `initialState`객체는 변하지 않는다. \n\n### Store에 Reducer추가하기\n이제 우리의 비어있는 컨테이너에 슬라이스를 추가하기 위해 처음에 만들었던 빈 `store`에 `slice`를 불러 넣는다.\n```js\nimport { configureStore } from '@reduxjs/toolkit'\nimport coounterReducer from '../features/counter/counterSlice'\n\nexport defualt configureStore({\n  reducer:{\n    counter: counterReducer  //추가\n  }\n})\n```\n추가한 `reducer`함수에는 `state`와 `action`모두를 담고으므로 `store`가 필요한 정보들은 모두 넘겨준 셈이다. `Provider`로 공급중인 `store`에 `state`와 `reducer`가 있으니 이제 컴포넌트에서 `state`에 접근할 수있고 변경할 수 있는 조건들을 모두 충족했다.\n\n### React Components에서 Redux State 사용하기\n이제 `useSelector`를 이용해 `state`에 접근할 수 있으며, `useDispatch`를 통해 `state`를 변경할 수 있다.\n```js\nimport React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\nimport { decrement, increment } from './counterSlice'\nimport styles from './Counter.module.css'\n\nexport function Counter() {\n  const count = useSelector(state => state.counter.value)\n  const dispatch = useDispatch()\n\n  return (\n    <div>\n      <div>\n        <button\n          aria-label=\"Increment value\"\n          onClick={() => dispatch(increment())} // state 변경\n        >\n          Increment\n        </button>\n        <span>{count}</span>\n        <button\n          aria-label=\"Decrement value\"\n          onClick={() => dispatch(decrement())} // state 변경\n        >\n          Decrement\n        </button>\n      </div>\n    </div>\n  )\n}\n```\n",
		"category": "posts",
		"createdAt": 1681115701129,
		"id": "react-redux",
		"tags": ["React"],
		"title": "React Redux"
	},
	"restful-api": {
		"author": "",
		"description": "RESTful API는 웹 개발에서 일반적으로 사용되는 아키텍처 스타일로 이를 통해 클라이언트와 서버간의 독립적인 개발과 api 자체의 확장성, 다양한 환경에서 호환성 유지한다. 표준 원칙들을 지키는 api는 프론트엔드와 백엔드 사이에 원활한 개발을 도와주며 동시에 둘을 독립적으로 유지시켜준다.",
		"body": "RESTful하다 라는 말을 자주 듣게 되는데, 이때마다 의도는 알 수 있어도 그 의미는 분명하지 않았다. 하지만 RESTful 하다는 의미를 어느정도 알고난 뒤에 생각해 보니, 프론트엔드를 공부하면서 사실 restful 하지 못한 api를 써본 경험이 없는것 같다. 외부 서비스를 이용할 때, 날씨, youtube 등 몇가지 api를 써봤을때도 rest api를 제공 받았고, 학원에서 프로젝트를 진행 할 때에도 백엔드에서 제공하는 api들은 모두 rest api라고 여겨진다.(적어도 나는 그렇게 사용했다.)\n\n## REST 아키텍처\nrest api는 rest 아키텍처를 준수하는 api를 말한다. 이는 api가 만들어 질 때 어떤 방식, 언어, 라이브러리등과 상관없이 REST가 요구하는 원칙을 준수하며 만들기만 하면 그만이다. 다음은 대표적인 REST 아키텍처의 원칙이다.\n\n1. Client-Server: 클라이언트와 서버는 서로 독립적으로 존재하며, 각자가 발전하고 변화하는데 서로가 영향을 주지 않아야 합다. \n\n2. Stateless: 각 요청은 모든 필요한 정보를 포함해야 한다. 즉, 서버는 클라이언트의 상태를 저장하거나 이전 요청을 기억하지 않는다.\n\n3. Cacheable: 서버는 클라이언트가 응답을 재사용할 수 있도록 응답 데이터의 캐시 가능성을 명시해야 한다. \n\n4. Uniform Interface: REST API는 일관된 인터페이스를 제공해야 한다.\n\n\n## 프론트엔드 관점\n위의 원칙들과 더불어 어떤 원칙들은 사실 프론트엔드 입장에서는 잘 느끼지 못하는 경우가 있다. 특히 Cacheable의 서버 메모리측 캐싱 측면에서는 서버 메모리에 캐싱되어 클라이언트의 동일 요청에 서버 자원을 소모하지 않는 방법이라, 이런 경우는 클라이언트가 느끼기 힘든 부분이다. \n아래는 프론트엔드 관점에서 보는 RESTful한 api의 특징들이다.\n\n1. 자원 중심적(Resource Oriented): REST API는 웹의 자원을 URL로 표현하며, 이를 통해 웹 자원에 대한 쉬운 접근이 가능합니다. 이러한 접근 방식은 프론트엔드 개발자가 필요한 데이터를 쉽게 찾아볼 수 있게 합니다.\n\n2. 표준 HTTP 메소드 사용: REST API는 표준 HTTP 메소드(GET, POST, PUT, DELETE 등)를 이용하여 자원에 대한 CRUD(Create, Read, Update, Delete) 연산을 수행한다. \n\n3. 플랫폼 독립적: REST API는 플랫폼에 독립적이다. 따라서, 프론트엔드 개발자는 다양한 언어와 프레임워크(예: React, Vue, Angular 등)에서 동일한 REST API를 사용할 수 있다.\n\n4. 스케일아웃이 용이: REST는 무상태(Stateless) 통신 방식을 사용하므로 서버의 확장이 쉽다. 이는 프론트엔드 개발자가 사용자 수가 많아져도 API가 안정적으로 동작한다는 보장을 받게 한다.\n\n5. 캐시 사용 가능: REST API의 응답은 캐시 가능하므로, 프론트엔드 개발자는 이를 활용해 애플리케이션의 성능을 향상시킬 수 있다. \n\n6. Self-descriptive: REST API는 그 자체로 메시지가 충분한 정보를 포함하고 있어서 어떻게 처리해야 할지를 알 수 있다. 이는 프론트엔드 개발자가 API를 쉽게 이해하고 사용할 수 있도록 한다.\n\n다시말해 사용하기 편하고 독립적이며 확장성이 있는 \"좋은\" api를 만들라는 뜻이며 개발자들이 추구해야 할 권장되는 원칙 같은 것이다.",
		"category": "posts",
		"createdAt": 1685080495612,
		"id": "restful-api",
		"tags": ["ETC"],
		"title": "RESTful API"
	},
	"styled-component": {
		"author": "",
		"description": "Styled Components는 React 애플리케이션에서 사용되는 CSS-in-JS 라이브러리다. 이 라이브러리는 JavaScript 파일 내에서 CSS 스타일을 정의하고 컴포넌트에 적용할 수 있게 해준다. Styled Components를 사용하면 CSS 클래스명을 작성하거나 별도의 CSS 파일을 생성할 필요 없이 컴포넌트에 스타일을 직접 적용할 수 있다.",
		"body": "## 기본 사용법\n```js\n// 기본 사용법\nconst Div = styled.div`\n\t/*style*/\n`\n\n// 상속하기\nconst Div2= styled(Div)`\n\t/*style*/\n`\n\n// Attributions 넣기\nconst InputWithAttrs = styled.div.attrs({required : true})`\n\t/*style*/\n`\n\n// Animation 넣기\nconst rotation = keyframes`\n  from {\n\ttransform:rotate(0deg);\n  }\n  to {\n\ttransform:rotate(180deg);\n  }\n`\nconst Div = styled.div`\n  /*style*/\n  animation: ${rotation} 1s linear;\n`\n\n//컴포넌트 안의 테그에 스타일 넣기\nconst Box = styled.div`\n  /*style*/\n  span {\n\t/*style*/\n\t&:hover{\n\t  /*style*/\n\t}\n  }\n  ${Component} {\n\t/*컴포넌트를 직접 넣을 수도 있음*/\n\t/*style*/\n  }\n`\n```\n## Themes and styled-components\n### `Props` 전달해주기\n하위 컴포넌트가 상위 컴포넌트로부터 `props`를 받을 수 있는것 처럼 `styled-components`도 `props`를 받아 활용 할 수 있다. \n```js\nconst Div = styled.div`\n  color: ${(props) => props.textColor};\n`\n...\n\n<Div textColor=\"black\" />\n```\n\n\n### 테마 적용하기\n\n`props`를 전달할 수 있다는 말은 스타일 요소가 동적으로 변할 수 있다는 말이다. 이를 이용하면 페이지의 테마 또한 동적으로 설정 할 수 있다. 먼저 `styled-components`의 `ThemeProvider`를 import해준 뒤, 사용 될 테마 설정을 해준다. 그리고 설정한 테마로 적용 될 컴포넌트 들을 감싸준다.\n```js\nimport {ThemeProvider} from \"styled-components\";\n\t...\n  const darkTheme = {\n    textColor: \"white\";,\n    backgroundColor: \"black\";\n    ...\n  }\n\n\t...\n\t<ThemeProvider theme={darkTheme}>\n  \t  <App />\n  \t<ThemeProvider />\n\t...\n```\n그럼 이제 `App` 컴포넌트와 그 하위 컴포넌트들의 `styled-components`는 `ThemeProvider`가 제공해 주는 `darkTheme`을 `prop`으로 받을 수 있게된다. 따라서 `App` 컴포넌트 안에서 `styled-components`를 이용하여 다음과 같이 사용 될 수 있다.\n```js\n// App.jsx 의 styled-components\nconst Text = styled.span`\n  color: ${(props) => props.theme.textColor};\n`\n```\n이를 이용하여 `lightTheme`등, 같은 속성명을 가지는 여러 테마들을 만들어 놓고 `ThemeProvider`에 `theme`으로 전달해주는 객체를 바꿔주면 쉽게 테마를 변경할 수 있다.",
		"category": "posts",
		"createdAt": 1681116241968,
		"id": "styled-component",
		"title": "Styled Component"
	},
	"time-ago": {
		"author": "",
		"description": "Time-ago 형식은 현재 시간과 과거 시간 간의 차이를 읽기 쉬운 방식으로 표현하는 방법이다. 이를 구현하기 위해 다양한 라이브러리와 기술이 존재하는데, 대표적인 예로 Moment.js와 date-fns 등이 있다.",
		"body": "유튜브는 비디오 생성 날짜 대신 **'3주 전'** 이나 **'1개월 전'** 과 같이 비디오가 얼마 전에 생성되었는지 나타내 준다. 이 표시는 사실 서버로부터 생성된 날짜와 시간을 받아온다면 현재 시간을 기준으로 바꿔주는건 그렇게 어려운일은 아닐 것이다. 하지만 이와같은 귀찮은 일을 대신 해주는 1kb대의 가벼운 패키지가 있어 공식문서를 토대로 간단하게 소개한다.\n\n## TimeAgo\n#### 설치\n```js\n$ npm install react-time-ago javascript-time-ago --save\n```\n리액트 타임어고는 자바스크립트 타임어고에 의존적이라 두개 다 추가한다.\n\n#### 초기화\n타임어고는 아래와 같은 초기화가 필요하다.\n```js\nimport TimeAgo from 'javascript-time-ago'\n\nimport en from 'javascript-time-ago/locale/en.json'\nimport ru from 'javascript-time-ago/locale/ru.json'\n\nTimeAgo.addDefaultLocale(en)\nTimeAgo.addLocale(ru)\n```\n### 불러오기 & 사용하기\n그 뒤에 리액트 타임어고를 불러서 쓰면 된다.\n```js\nimport ReactTimeAgo from 'react-time-ago'\n<ReactTimeAgo date={publishedAt} />\n```\n다만 `date`에 들어가야할 데이터 형식은 `Date instance`여야 하므로 `new Date()`에 담아줘야 에러가 생기지 않는다.\n\n### 사용예시\n한국어도 지원하는데 한국어를 기준으로 사용 예시는 아래와 같다. \n```js\nimport TimeAgo from 'javascript-time-ago'\nimport ko from 'javascript-time-ago/locale/ko.json'\n\nimport ReactTimeAgo from 'react-time-ago'\n\nTimeAgo.addDefaultLocale(ko)\n// ...\n <ReactTimeAgo date={new Date(publishedAt)} />\n```\n`TimeAgo`와 언어설정인 `ko`를 불러와서 불러온 `TimeAgo`를 이용하여 기본 언어 설정을 한국어로 해준 뒤에, `ReactTimeAgo`를 불러와 컴포넌트처럼 쓰면 된다. 다만, `date` 속성에는 `Date instance`로 들어가야 하므로 사용 하는 자료형에 따라 `new Date()`를 이용하여 `date intance`로 바꿔줘야 할 소요가 생길 수 있다.\n\n이 외의 기능들이나 더 자세한 사항은 [공식 문서](https://www.npmjs.com/package/react-time-ago)를 통해 확인 가능하다. ",
		"category": "posts",
		"createdAt": 1681116177781,
		"id": "time-ago",
		"tags": ["React"],
		"title": "Time Ago"
	},
	"usememo-usecallback": {
		"author": "",
		"description": "useMemo와 useCallback은 성능 최적화와 함수 메모이제이션을 위해 사용된다. useMemo는 동일 입력에 대해 이전 값을 재사용하는데 사용되어 불피요한 재계산을 줄여주며, useCallback은 함수의 재 렌더링을 막아 자식컴포넌트에 전달되는 함수는 자식컴포넌트의 불필요한 렌더링도 막아준다.",
		"body": "`useCallbak`과 `useMemo`는 리액트 앱의 대표적인 성능개선 훅으로 리액트 앱의 과도한 리렌더링을 방지하여 앱의 성능을 향상시킨다. 작동 원리는 리액트 쿼리의 키와 같이 두 함수 모두 의존값을 가지는 배열을 하나 만들어 의존값이 변하지 않을때는 기존에 저장한 값을 사용하고 의존값이 바뀔 때에만 연산을 통해 값을 반환한다. \n```js\nconst memoizedCallback = useCallback(() => {\n  // 함수 로직\n}, [dependency]);\n```\n## useMemo \n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction calculateExpensiveValue(count) {\n  // 복잡한 연산 수행\n  return count * 10; // 예시를 위해 간단한 연산\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [otherValue, setOtherValue] = useState(0);\n\n  const expensiveValue = useMemo(() => calculateExpensiveValue(count), [count]);\n  //otherValue의 변경으로 컴포넌트가 다시 렌더링 되더라도 count는 계산되지 않고 값이 재사용됨.\n  return (\n    <div>\n      <p>Expensive Value: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Increase Count</button>\n      <button onClick={() => setOtherValue(otherValue + 1)}>Increase Other Value</button>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n원래 컴포넌트 내의 상태(state)가 변하면 컴포넌트가 리렌더링 되면서 `expensiveValue`가 다시 계산되어야 한다. 하지만 위 예에서는 `expensiveValue`가 `useMemo`로 `count`의 변경에 의존해서만 계산되기 때문에 이전 값을 재사용 하기 때문에 계산이 복잡할수록 `useMemo`로 성능 향상을 기대할 수 있다. \n\n## useCallback\n`useMemo`를 사용하는 상황은 비교적 단순하다. 복잡한 연산을 필요로 하는 작업을 줄이는 방향으로 설계하면 이또한 좋은 방법이 되기 때문이다. 하지만 `useCallback`은 약간 사정이 다르다. `useCallback`은 로직의 재활용이 가능하게 해줘서 함수가 속한 컴포넌트가 리렌더링 될 때, 함수의 재선언을 방지해 주는 역할에 그치기 때문에 함수의 재선언 작업정도만 줄여주기 때문이다. \n따라서 `useCallback`을 사용할때에는 몇가지 상황을 고려할 수 있다.\n\n1. 자식 컴포넌트에 함수를 전달할 때: 부모 컴포넌트가 리렌더링될 때마다 새로운 함수 참조가 생성되어 자식 컴포넌트에 전달되면, 자식 컴포넌트도 불필요하게 리렌더링될 수 있다. 이런 경우 `useCallback`을 사용하여 함수 참조를 유지하면, 자식 컴포넌트의 불필요한 리렌더링을 방지할 수 있다.\n\n2. 빈번한 이벤트 처리: 빈번한 이벤트 처리, 예를 들어 스크롤 이벤트나 마우스 이동 이벤트 같은 경우, 매 이벤트 발생마다 새로운 함수가 생성되지 않도록 `useCallback`을 사용해 함수의 재생성을 줄일 수 있다.\n\n3. 메모이제이션된 자식 컴포넌트: `React.memo`를 사용하여 최적화된 자식 컴포넌트가 있고, 이 컴포넌트에 함수를 전달할 경우 `useCallback`을 사용하여 함수 참조를 유지함으로써, 불필요한 자식 컴포넌트의 리렌더링을 방지할 수 있다.\n\n",
		"category": "posts",
		"createdAt": 1681986632055,
		"id": "usememo-usecallback",
		"tags": ["React"],
		"title": "useMemo와 useCallback"
	},
	"approuter-datafetching": {
		"author": "",
		"body": "## Fetching Data on the Server\ndata fetching은 서버에서 이루어지는 것이 성능면에서 좋기 때문에 서버 컴포넌트에서 이루어 지는 것을 권장된다. 서버 컴포넌트에서 데이터를 fetching하면 아래와 같은 이점들이 있다.\n\n- 클라이언트가 민감한 정보를 관리할 필요가 없어 보안에 유리\n- 동일 fetching에 대해 서버가 자동으로 캐싱 데이터를 제공\n- Database위치에 따라 latancy를 줄일 수 있고 성능 개선 여지가 있음\n- waterfall을 줄일 수 있음\n\n>layout에서 fetching한 데이터는 자식 컴포넌트로 전달해 줄 수 없다. 그럼에도 불구하고 nextjs는 layout에서 필요한 data fetching을 수행하기를 권장하는데 이는 nextjs가 중복 요청을 없애주고 data를 캐싱해 주기 때문이다.\n\n## Parallel and Sequential Data Fetching\n\n데이터 패칭이 컴포넌트에서 일어날 때 waterfall이 발생한다. 이는 초기 렌더링 시간을 불필요하게 늘리는 일이므로 여러 데이터 패칭은 병렬적으로 이뤄지는 것이 좋다.\n\n![](https://velog.velcdn.com/images/latemarch/post/7b033cc6-f6d3-4d74-a139-d46ddf8b56d3/image.png)\n\nwaterfall을 피하고 병렬 요청을 하기 위해서 `Promise.all`을 사용 한다.\n\n```js\nimport Albums from './albums'\n \nasync function getArtist(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}`)\n  return res.json()\n}\n \nasync function getArtistAlbums(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n  return res.json()\n}\n \nexport default async function Page({\n  params: { username },\n}: {\n  params: { username: string }\n}) {\n  // Initiate both requests in parallel\n  const artistData = getArtist(username)\n  const albumsData = getArtistAlbums(username)\n \n  // Wait for the promises to resolve\n  const [artist, albums] = await Promise.all([artistData, albumsData])\n  // 이 부분에서 모든 요청 병렬 처리\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums}></Albums>\n    </>\n  )\n}\n```\n\n## SSR, SSG, ISR  \n\n[이전 글](https://latemarch.vercel.app/posts/nextjsapprouter)에서 App router를 선택 시 기본 값으로 모든 컴포넌트가 SSR이 된다고 했다. page router에서는 `getserversideprops/getstaticprops`로 렌더링 방식을 페이지 단위로 결정했지만 App router에서는 `fetch()`가 그 역할을 대신한다. \n\n### SSG\n\n기본적으로 `fetch()`는 static fetch로 설정 되어 있다.이말은 빌드 시점에서 데이터를 가지고 와서 캐싱되고, 같은 요청에 대해 이를 재사용한다는 말이다. (Static site처럼 행동)\n```js\nfetch('https://...') // cache: 'force-cache' is the default\n```\n따라서 개발자는 필요에 따라 데이터의 revalidate를 설정하거나 데이터가 캐싱되지 않게 설정해서 데이터 업데이트를 관리해야 한다.\n\n### ISR\n`fetch()`에 revalidate를 설정하여 일정 시간마다 데이터를 업데이트 하면 해당 컴포넌트는 ISR이 된다.\n```js\nfetch('https://...', { next: { revalidate: 10 } })\n```\n위 코드는 다음 10초 후에 백그라운드에서 다시 데이터 요청을 한다\n\n### SSR\n매 요청마다 새로운 데이터 요청을 보내려면 데이터를 캐시하지 않는 옵션을 사용해야 한다.\n```js\nfetch('https://...', { cache: 'no-store' })\n```\n이제 데이터는 캐싱되지 않고 컴포넌트는 SSR이 된다.\n\n## Data Caching\n\n위에서 `fetch()`를 사용하면 서버에서 자동으로 데이터를 캐싱해서 재사용 하므로 각 컴포넌트마다 데이터 패칭 함수를 재사용 하더라도 서버에서 자동으로 중복 요청을 제거하고 캐싱된 데이터를 사용했다. (nextjs에서 권장하는 방식) 하지만 `fetch()` api는 로컬 경로에 있는 데이터를 가지고 오지 못해, 로컬에 json으로 저장된 데이터를 가지고 오려면 react `cache`를 사용해야 한다.\n\n```js\n// utils/getUser.ts\nimport { cache } from 'react'\n \nexport const getUser = cache(async (id: string) => {\n  const user = await db.user.findUnique({ id })\n  return user\n})\n\n// app/user/[id]/layout.tsx\nimport { getUser } from '@utils/getUser'\n \nexport default async function UserLayout({ params: { id } }) {\n  const user = await getUser(id)\n  // ...\n}\n```\n\n",
		"category": "posts",
		"createdAt": 1686491311053,
		"description": "app router에서 fetch() api는 서버에서 데이터를 캐싱하고 컴포넌트의 렌더링을 결정한다. 캐싱 뿐만 아니라 동일 요청을 자동으로 제거하고 병렬 요청을 지원하며 패칭 시간을 크게 절약한다. 또한 react에서 제공하는 chech()는 fetch()로 가지고 올 수 없는 데이터들을 캐싱하도록 도와준다.",
		"id": "approuter-datafetching",
		"tags": ["Nextjs"],
		"title": "App Router - data fetching"
	},
	"ecma": {
		"author": "",
		"body": "자바스크립트는 웹 브라우저 엔진에서 single-threaded로 동작한다. 싱글 스레드라는 뜻은 한번에 한가지 작업만 할 수 있으며 흔히 말하는 멀티테스킹이 불가능하다는 말이다. \n\n## Call Stack\n자바 스크립트는 함수의 실행을 관리하기 위해 후입선출 원칙의 콜 스택을 사용하는데 함수가 호출되는 시점에 스택의 맨 위에 추가(push)되며 추가된 함수의 실행이 완료되면 스택에서 제거(pop)된다. 그런데 뭔가 이상하다. 스크립트를 위에서 아래로, 왼쪽에서 오른쪽으로 코드를 읽는다면 스택이 아니라 선입선출인 큐에 쌓여야 맞는것 아닐까?\n\n### 어땟든 스택으로\n\n```js\nfunction function1() {\n    console.log('Function 1 starts');\n    function2();\n    console.log('Function 1 ends');\n}\n\nfunction function2() {\n    console.log('Function 2 starts');\n    function3();\n    console.log('Function 2 ends');\n}\n\nfunction function3() {\n    console.log('Function 3 starts and ends');\n}\n\nfunction1();\n\n//stack [ ftn1, ftn2, ftn3]\n\n//출력\n//Function 1 starts\n//Function 2 starts\n//Function 3 starts and ends\n//Function 2 ends\n//Function 1 ends\n```\n위 예제에서 콜 스택은 최대 3개까지 쌓이게 되고, 마지막에 추가된 `function3`가 처음으로 스택에서 제거(pop)되며 이후에 `function2`, `function`의 순서로 함수가 실행되며 스택이 비워진다.\n\n그렇다면 아래의 경우는 어떨까? \n```js\nfunction function1() {\n    console.log('Function 1 is running');\n}\n\nfunction function2() {\n    console.log('Function 2 is running');\n}\n\nfunction function3() {\n    console.log('Function 3 is running');\n}\n\nfunction1();\nfunction2();\nfunction3();\n\n//출력\n//Function 1 is running\n//Function 2 is running\n//Function 3 is running\n```\n\n먼저 설명한 대로만 생각한다면 콜 스택에 함수가 1,2,3번 순으로 쌓여서 3,2,1순으로 실행되어야 할것 같다. 하지만 독립적으로 실행되는 함수들을 콜스택에 쌓이지 않는다. 콜 스택에 처음 추가된 `function1`은 `function2`가 스택에 쌓이길 기다리지 않고 실행된다. 오히려 `function2`는 `function1`이 콜 스택에서 제거되기를 기다리고 있는 것이다. 즉, 콕 스택에 함수가 두개 이상 쌓이는 경우는 (동기적 작업에서)콜백 함수가 존재할 때이다. \n\n## 비동기 작업\n 분명 자바스크립트는 싱글 스레드로 한번에 한가지 작업만 할 수 있다고 했다. 하지만 자바스크립트는 분명히 비동기 작업으로 여러가지 작업을 한번에 수행하는것 처럼 보인다. 비동기 작업은 Web Apis라는 브라우저에서 제공하는 별도의 스레드에서 실행된다. 이 경우에도 자바 스크립트 내부에서 실행되는 것이 아니라 일종의 '외주'를 주는 일이기 때문에 우리의 ECMA회사는 여전히 한번에 한가지 일만 수행하고 있다. 그렇다면 자바스크립트는 이 '외주'를 준 일들을 어떻게 관리할까?\n \n### 이벤트 루프와 큐\n비동기 작업이라고 하더라도 일단 콜 스택에 추가 된 후, Web Api에 작업을 위임하면서 스택에서 제거된다. 콜 스택에서 제거된 비동기 작업은 **처리가 완료 된 후** 이벤트 큐로 옮겨지게 된다.(비동기 작업들은 자바스크립트와 달리 병렬처리 됨) \n\n이벤트 큐로 옮겨진 비동기 작업의 결과들은 자바스크립트에서 처리될 순서를 기다린다. 이를 이벤트 루프가 큐와 스택을 계속 확인하며 비동기 작업의 결과들을 처리한다. 이벤트 큐에서 순서를 기다리는 결과들은 **콜 스택이 비어있을 때에만** 콜 스택에 추가 되어 자바스크립트에 의해 다뤄질 수 있다. \n\n> 데이터 패칭에서 await를 누락하는 실수를 하면 Web api로 위임하기 전인 Promise객체가 반환된다. await를 앞에 붙여야 Web api에서 처리된 Promise가 fulfilled되고, 이벤트 큐에서 대기 했다가 콜 스택에 추가되어 자바스크립트 스레드에서 처리되어 얻고자 한 데이터를 반환 받을 수 있다.\n\n### 블로킹\n앞선 함수가 스택에서 제거 되면 동기적 작업들이 이벤트 큐의 작업들보다 우선순위를 가진다. 따라서 동기적 작업들이 많이 밀려있다면, 이벤트 큐의 작업들은 콜 스택에 추가될 수 없고 이벤트 큐에서 대기해야 한다. 이를 블로킹 이라고 한다. 이런 이유로 시간이 많이 걸리는 작업은 병렬처리가 가능한 Web api로 작업을 위임 하여 블로킹 현상을 방지 하고 메인 스레드는 많은 작업들을 처리하게 하는 것이 중요하다.\n\n\n\n \n ",
		"category": "posts",
		"createdAt": 1690446199302,
		"id": "ecma",
		"description": "데이터 패칭을 할 때, 가끔 await를 누락하는 실수를 하면 패칭된 데이터가 아닌 프로미스 객체를 반환 받는 경우가 생긴다. 이를 이해하기 위해선 자바스크립트의 동작원리를 알아야한다. single threaded인 자바 스크립트가 어떻게 비동기 작업을 다루고 멀티 테스킹이 가능한 것처럼 보이는지 알아보자.",
		"tags": ["ES"],
		"title": "자바스크립트 동작방식"
	},
	"restarchitecture": {
		"author": "",
		"body": "REpresentational State Transfer의 약자인 REST는 \"분산 하이퍼미디어 시스템을 위한 아키텍처 스타일\"로  웹과 같은 네트워크 시스템에서 텍스트, 이미지, 오디오 등 다양한 형태의 미디어와 링크를 통해 연결된 정보를 다루기 위한 디자인 원칙과 구조이다.\n\n사실 주로 API를 소비하는 프론트엔드 입장에서는 API에 특정 아키텍처의 원칙을 적용하면서 오는 장단점이나 어려움을 알기 힘들다. 다만 추상적으로나마 REST API에 대해 생각해 본바를 기록해 두고자 이 포스팅을 작성한다.\n\n## 왜 REST인가?\nAPI가 REST 아키텍처를 따르면서 오는 가장 큰 장점은 시스템의 통제와 서버와 클라이언트간의 독립적인 확장성 일 것이다. 그렇다면 시스템에 대한 (필요한 만큼의)완전한 통제가 가능하고 서버와 클라이언트가 (통제할 수 있는)독립적인 진화가 가능하다면 REST 아키텍처의 제한들을 모두 지키지 않아도 API는 REST 아키텍처를 따르려고 하면서 목표했던 목적들은 모두 이룬 셈이다.\n\n## REST API\nREST 아키텍처를 따르는 API를 만들기 위해선 [이전글] (https://latemarch.vercel.app/posts/restful-api)에 소개된 원칙들을 지켜야 한다. 웹에서 작동하는 API들은 HTTP프로토콜을 기반으로 작동하기 때문에 이로써 자동으로 대부분의 REST 아키텍처가 제시하는 원칙들을 지키게 된다. 다만 \"Uniform Interface\"에서 문제가 생길 수 있다.\n\n#### Uniform Interface\nUniform Interface 원칙은 다음과 같은 네 가지 원칙들로 구성된다.\n\n1. Resource-Based(자원 기반): 웹 서비스는 자원을 식별하고 이를 구별하는 데 중점을 둡니다. 각 자원에는 고유한 URL이 할당되고, 이 URL을 통해 해당 자원을 참조하고 조작할 수 있습니다.\n\n2. Manipulation of Resources Through Representations(표현을 통한 자원 조작): 클라이언트가 서버에 자원을 요청하면, 서버는 해당 자원의 표현(representation)을 전송합니다. 이 표현은 JSON, XML 등의 형식으로 되어있을 수 있습니다. 클라이언트는 이 표현을 이용해 자원을 업데이트하거나 삭제할 수 있습니다.\n\n3. Self-descriptive Messages(자기 서술적인 메시지): 각 메시지는 자원을 처리하는 데 필요한 충분한 정보를 포함해야 합니다. 이는 미디어 타입이나 메시지의 메타데이터를 통해 제공될 수 있습니다.\n\n4. Hypermedia as the Engine of Application State (HATEOAS, 애플리케이션 상태의 엔진으로서의 하이퍼미디어): 클라이언트가 어플리케이션 상태(현재 상태, 다음 상태 등)를 변경하는데 필요한 모든 정보를 서버로부터 얻을 수 있어야 합니다. 이 정보는 일반적으로 하이퍼링크 형태로 제공됩니다.\n\n이중에서도 아래 두가지가 문제가 될 수 있다. API는 \"충분한\"자기 서술적인 메시지가 아니다. 또한 여느 API응답이 그렇듯이 HATEOAS하지 않은것은 명백해 보인다. 아래는 API으답 예시이다.\n```js\nHTTP/1.1 200 OK\nDate: Mon, 26 Jul 2023 05:00:00 GMT\nServer: API Server\nContent-Type: application/json\nContent-Length: 81\nConnection: keep-alive\n\n{\n  \"city\": \"Seoul\",\n  \"weather\": \"Clear\",\n  \"temperature\": 286.55\n}\n```\n우리가 보기엔 충분한 정보이지만 API는 기계-기계 통신 이므로 충분한 자기 서술적이지 못할 수 있다. 헤더에 담긴 정보들로 데이터를 파싱하여 manipulate한 값으로 변환할 수는 있어도 city, weather, temperature와 같은 키값과 그에 대응되는 값들은 명시되기 전까지 컴퓨터에게는 무의미한 것들이다.\n\n## 그것들은 정말 필요한가?\n앞서 REST아키텍처가 추구하는 것은 서버와 클라이언트간의 독립적인 진화(Seperation of Concerns)라고 하였다. 서버에 변경사항이 있어 응답이 달라져야만 한다면 \"충분히\" 자기 서술적이지 못한 응답은 클라이언트에게 예기치 못한 오류를 야기할 수 있다. 또한 HATEOAS하지 못하면 서버 개발이 진행되면서 처음에 정해두었던 전이들에도 제한 사항이 생길 수 있다. 따라서 서버와 클라이언트 간에 충분한 독립적 진화가 이뤄지지 않는다.\n\n## RESTful할 필요가 있을까?\n위 예시에서 부족한 점을 채우는 방법은 분명 존재할 것이다. 자료형을 바꿔 `link`속성을 추가하고 `link`를 포함한 모든 키와 값들에 대해 명시한다면 RESTful API를 만들 수 있을 것이다. 문제는 이런 과정이 필요한가인데 다른 개발자들을 보면 그렇지는 않은것 같다. 만약 진정으로 이 작업이 필요했다면 우리가 알고 API응답의 모습이 지금과는 많이 다를 것이다. 그리고 우리는 \"적당히\" REST 아키텍처의 원칙들을 따르는 API를 REST API라고 부르고 있기도 하다.\n\n따라서, 오늘날 우리가 사용하고 만들고 있는 REST API는 사실 REST API가 아니었던 것. (~~제안자인 Roy T. Fiedling도 제발 이름좀 바꿔달라고 애원중~~) 하지만 개발자들은 API를 만들면서 REST 아키텍처가 추구하는 목적을 공유하고 있다고 볼 수 있다.\n\n이 글은 아래의 출처를 바탕으로 작성하였음.\n출처: [그런 REST API로 괜찮은가](https://youtu.be/RP_f5dMoHFc)",
		"category": "posts",
		"createdAt": 1690478733149,
		"id": "restarchitecture",
		"description": "REpresentational State Transfer의 약자인 REST는 분산 하이퍼미디어 시스템을 위한 아키텍처 스타일이다. 주로 API를 소비하는 프론트엔드 입장에서는 API에 특정 아키텍처의 원칙을 적용하면서 오는 장단점이나 어려움을 알기 힘들다. 다만 추상적으로나마 REST API에 대해 생각해 본바를 기록해 두고자 이 포스팅을 작성한다.",
		"tags": ["ETC"],
		"title": "REST 아키텍처와 API"
	},
	"afterdomain-network": {
		"author": "",
		"body": "\"주소창에 google.com을 치면 이후에 어떤일이 일어나나요?\" \n\n대표적인 면접 질문으로 개발자로써 알아야할 많은 것들을 담고 있는 질문이다. 이질문에 대한 답을 알아보기 전에 **OSI 7 계층 모델**을 알아두면 이해하는데 도움이 된다. 아래의 OSI 7 계층 모델에 대한 설명은 필요할떄마다 위로 올라와 확인하는 것으로 족하다.\n>OSI 7 계층 모델:\n>- 계층 7: 응용 계층(Application Layer): 사용자와 가장 가까운 계층으로, 이메일, 웹브라우저 등의 애플리케이션 서비스가 이루어집니다.\n>- 계층 6: 표현 계층(Presentation Layer): 데이터의 인코딩 및 디코딩, 암호화 및 복호화 등을 처리합니다.\n>- 계층 5: 세션 계층(Session Layer): 네트워크상의 두 노드간의 연결 세션을 관리합니다.\n>- 계층 4: 전송 계층(Transport Layer): TCP/UDP와 같은 프로토콜이 이 계층에서 동작하여 신뢰성 있는 데이터 전송을 보장합니다.\n>- 계층 3: 네트워크 계층(Network Layer): IP 프로토콜을 포함하여 패킷의 경로를 결정하고 네트워크간의 라우팅을 담당합니다.\n>- 계층 2: 데이터 링크 계층(Data Link Layer): 네트워크 기기 간의 데이터 전송을 관리하며, MAC 주소를 활용합니다.\n>- 계층 1: 물리 계층(Physical Layer): 실제 데이터를 전기적 신호로 변환하여 네트워크 매체를 통해 전송하는 역할을 합니다.\n\n1계층(물리 계층)과 2계층(데이터 링크 계층)은 실제로 일어나고 있지만 일반적으로 웹 브라우징과 같은 높은 수준(high level)의 작업에서는 특별히 언급하지 않는다. 이제 주소창에 어떤 도메인을 입력(7:Application Layer)하면 어떤 일이 일어나는지 알아보자.\n## DNS (4: Transport Layer)\n주소창에 도메인을 입력하면 가장 먼저 도메인에 대응하는 IP 주소(Internet Protocol Address: 인터넷 프로토콜에 의해 컴퓨터나 장치에 할당되는 고유한 식별자)를 찾아야한다. 도메인은 사람들이 알아보기 쉽게 나타낸 별명이 뿐이고, 서버에 연결하여 무엇인가 응답을 받으려고 한다면 내부적으로는 IP 주소가 필요하다. DNS(Domain Name System)는 흔히 전화번호부에 비유된다. 그도 그럴것이 DNS는 이름 그대로 도메인의 이름을 담은 서버이기 때문이다.\n\n1. 사용자가 웹 브라우저에 웹사이트 로드요청을 보내면 컴퓨터는 IP 주소를 찾기 위해 가장 가까운 전화번호부(DNS서버)를 찾게 된다. DNS는 하나만 존재하는 것이 아니다. 그래서 우선 가장 가까운 Local DNS캐시에서 IP를 찾는다. \n\n2. 만약 DNS캐시에 원하는 IP가 없다면 브라우저는 DNS요청 쿼리를 DNS 재귀 리졸버(DNS recursive resolv er)로 보내게 되다. 이제 이 리졸버가 도메인 이름을 IP주소로 변환하는 일련의 작업들을 대신 수행하게 된다. 이 리졸버는 일반적으로 사용자의 ISP에서 담당한다.\n\n3. 리졸버가 가장 처음 하는 일은 root nameserver에서 TLD(top level domain)서버를 찾는 것이다.(이 경우도 캐시되어있으면 생략됨) root nameserver는 모든 TLD서버의 위치를 가지고 있다.\n\n4. TLD 서버는 .com 이나 .org와 같은 레벨의 서버라고 볼 수 있다. 하지만 이 서버에서도 google.com을 포함한 모든 하위 도메인에 대한 정보를 가지고 있기 힘들기 때문에 권한 있는 네임서버(Authoritative Nameserver)에 최종 권위를 위임하게 된다.\n\n5. 처음에 도메인을 이용해 IP주소를 찾는 임무를 맡은 리졸버는 드디어 답을 찾을 수 있는 곳에 도달했다. 권한 있는 네임서버(Authoritative Nameserver)는 특정 도메인에 대한 DNS 질의에 대해 응답할 수 있는 네임서버이다. 이 서버는 요청한 도메인에 대한 모든 정보를 알고 있으며, 다른 서버나 클라이언트가 도메인에 대한 특정 정보를 요청하면 그에 대해 응답할 수 있다.\n\n지금까지도 한 일이 많다. 하지만 이제 어디로 가야할지 알았을 뿐이다.\n\n## TCP/IP\n\n#### IP (3: Network Layer)\n IP(Internet Protocol)프로토콜(이하 IP)은 데이터를 효율적으로 전달하기 위한 일련의 규칙을 정의하는데, 이 규칙에 따르면, 데이터는 패킷이라는 작은 단위로 분할되고, 각 패킷에는 출발지 IP 주소와 목적지 IP 주소가 부여된다. 위에서 목적지 IP 주소를 알았으니, 이제 데이터 전송을 위해 IP를 적용할 준비가 된것이다. 비연결 상태인 사용자와 서버를 IP를 사용하여 연결할 수 있다. IP는 사용자로부터 서버까지의 경로를 지정해준다.(사실 서버가 있는 네트워크까지의 경로를 보장하며, 이후는 포트번호에 따라 서비스에 전달된다) 이제 사용자와 서버간의 데이터 전송이 가능하게 된 것이다.\n#### TCP (4: Transport Layer)\n\"어디로\" 데이터(패킷) 전송하는 것만으로는 충분하지 않다. 데이터를 \"어떻게\" 안전하게 전송할 것인가도 중요한 문제이다. 그리고 이를 TCP(Transmission Control Protocol)가 담당한다. TCP는 우선 three-way handshake이란 방법으로 사용자와 서버간의 안전한 연결을 설정한다. **(5:Session Layer)**\n- SYN(Synchronize Sequence Numbers): 클라이언트가 연결 요청을 시작하면서 임의의 시퀀스 번호를 생성하고 이를 SYN 패킷에 포함시켜 서버에 전송한다.\n- SYN-ACK: 서버가 \"클라이언트의 SYN\" 패킷을 받으면, 이를 확인하고 자신의 임의의 시퀀스 번호를 생성한 후(SYN), 메시지가 성공적으로 수신되었음을 확인하는 메세지로 클라이언트의 시퀀스 번호에 1을 더한 값을 ACK 번호로 설정한 SYN-ACK 패킷을 클라이언트에게 전송한다.\n- ACK(Acknowledgment): 클라이언트는 서버의 SYN-ACK 패킷을 받고, 서버의 시퀀스 번호에 1을 더한 값을 ACK 번호로 설정한 ACK 패킷을 서버에게 전송하여 연결을 확립한다.\n\n연결이 설정되고 데이터를 전송하기 시작하면 TCP는 데이터를 작은 조각들로 나눠 TCP 세그먼트에 담게 된다. \n\n>#### TCP 세그먼트가 포함하는 정보들\n>- **소스 포트와 목적지 포트** \n>- TCP 세그먼트가 전송될 순서정보를 담은 **시퀀스 번호** \n>- 수신측이 이미 받은 세그먼트의 정보를 담은 **확인 응답 번호** \n>- 그리고 세그먼트의 무결성을 확인할 **체크섬**\n\n1. 만들어진 TCP 세그먼트는 IP 레이어로 전달된다.\n\n2. 이제 TCP 세그먼트에 세그먼트의 원점 IP 주소와 목적지 IP 주소를 담은 \nIP 헤더가  추가 하여 **IP 데이터그램**을 만드는데 이 IP 데이터그램이 인터넷을 통해 전송 된다. \n\n3. 그리고 데이터그램이 수신지에 도착하면, IP 레이어에서 IP 데이터그램의 IP 헤더를 제거하고 다시 TCP 세그먼트로 만들어서 TCP 레이어로 전달한다.\n\n4. 이제 TCP 레이어에서는 TCP 헤더를 분석하여 해당 세그먼트가 어느 애플리케이션에 속하는지, 어떤 순서로 재조립해야 하는지 등을 판단한다. \n\n#### 체크섬\nTCP 에서 데이터의 무결성을 확인하는 주요 방식은 체크섬(checksum)을 사용하는 것이다.\n\n체크섬은 보내는 측에서 데이터 패킷에 대해 계산되며, 이 계산된 값이 데이터 패킷과 함께 수신측에 전되는데, 수신측에서는 전송된 데이터 패킷에 대해 같은 체크섬 계산을 수행하고, 계산된 체크섬이 보낸 측에서 받은 체크섬과 일치하는지 확인한다.\n\n이 방법으로, 데이터의 무결성이 보장되며, 패킷의 손상 여부를 감지할 수 있다. 만약 체크섬이 일치하지 않는다면, 이는 패킷이 전송 중에 손상되었을 수 있음을 나타내고, TCP는 재전송 요청을 보내 손상된 패킷을 다시 받는다.\n\n그러나 TCP 체크섬은 기본적인 오류 검출 메커니즘을 제공할 뿐이며, 모든 종류의 오류를 검출할 수 있는 것은 아니다. 특히 체크섬은 악의적인 공격이나 데이터 변조를 검출하는 방법으로 사용되지는 않아서, 이러한 보안 문제를 해결하기 위해 보안 프로토콜인 SSL/TLS 같은 기술을 사용한다.\n\n\n## HTTP/HTTPS\n\n#### http\nIP는(3: Network Layer) 네트워크상에서 데이터 패킷을 효율적으로 전달하는 방법을 정의했다. 그리고 이후에 TCP로(4: TransPort Layer) 데이터 전송을 위한 세션 관리(5: Session Layer)와 데이터의 신뢰성을 보장하는 방법을 정의 했다. 이제 데이터를 주고받는 방법에 대해서 정의해야 한다. 이를 HTTP(Hypertext Transfer Protocol)가 담당한다. \n\n1. 클라이언트(예: 웹 브라우저)가 HTTP 요청을 생성할 때, 이 요청은 요청 메소드(GET, POST, PUT, DELETE 등), URL, 헤더 정보, 그리고 선택적으로 본문(body)로 구성된다. 클라이언트는 이 HTTP 요청을 웹 서버에 전송한다. \n\n2. 웹 서버는 요청을 요청 메소드와 URL, 그리고 요청 본문에 담긴 정보에 따라  처리합니다. \n\n3. 웹 서버는 처리한 결과를 HTTP 응답은 상태 코드(200, 404, 500 등), 헤더 정보등을 담아 HTTP 응답으로 클라이언트에게 돌려준다. \n\n4. 클라이언트는 HTTP 응답을 받아 처리(6: Presentation Layer) 하게 되는데, 웹 서버에서 보내는 데이터를 JSON, XML, HTML등과 같은 상황에 맞는 데이터를 알맞게 변환하는 작업을 한다.\n\n실제로 이 데이터를 어플리케이션(여기서는 웹 브라우저)이 어떻게 사용할지, 어떻게 표현할지는 7계층인 Application Layer에서 다루게 되기 때문에, HTTP로 웹 데이터를 받는 일까지는 Presentation Layer에서 일어나는 일의 일부이다. \n\n>#### Application Layer 로써의 HTTP\n>OSI 모델에서 7계층은 Application Layer로, 여기에서는 특정 프로그램이나 애플리케이션이 네트워크를 통해 데이터를 송수신하는 것을 총괄하게 된다. HTTP가 Application Layer의 프로토콜로 분류될 수 있는 이유는 HTTP가 클라이언트와 서버 사이의 '인터페이스' 역할을 수행하기 때문이다. 일반적으로 '인터페이스'라는 용어는 두 시스템이나 컴포넌트가 상호작용하는데 사용되는 공통된 방법이나 절차를 설명하는데, HTTP 프로토콜이 클라이언트(보통 웹 브라우저)와 서버 간의 통신 방식을 정의하며, 이를 통해 클라이언트가 서버에서 원하는 정보를 요청하고 받아올 수 있도록 해주기 때문이다. 그러므로, **_HTTP가 애플리케이션 데이터의 생성과 소비를 관리_** 하게 되고 이와 같은 이유로 HTTP를 7계층인 Application Layer의 프로토콜로 분류하기도 한다.\n\n\n#### https\n \nHTTPS는 HTTP 프로토콜의 보안이 강화된 버전으로, HTTP에 TLS(Transport Layer Security) 또는 그 이전 버전인 SSL(Secure Sockets Layer)을 추가하여 구현 되었다. 이 두 프로토콜은 데이터를 암호화하여 전송함으로써 전송 과정에서 해독되거나 수정되지 않게 보호 하므로써 데이터의 기밀성을 보장하고 인터넷을 통해 데이터를 안전하게 전송한다. \n\nHTTPS가 사용되는 경우 URL은 \"https://\"로 시작하며, 웹 브라우저는 보통 주소 표시줄에 자물쇠 아이콘을 표시하여 사용자에게 현재 사이트가 안전하다는 것을 알려준다.\n\nHTTPS는 다음과 같은 이점을 제공합니다:\n\n- 기밀성: 사용자의 정보가 암호화되어 전송되므로, 중간에서 데이터를 가로채도 원본 내용을 이해할 수 없다.\n- 무결성: 전송되는 데이터가 도중에 변조되지 않음을 보장한다.\n- 인증: 사용자는 서버가 자신을 속일 수 없으며, 실제로 통신하고 있는 상대가 의도한 상대임을 확인할 수 있다.\n\n이러한 이유로 HTTPS는 웹 사이트에서 민감한 정보(예: 신용 카드 번호, 비밀번호 등)를 처리할 때 권장되는 프로토콜이다. 또한 웹사이트의 SEO(Search Engine Optimization, 검색 엔진 최적화) 점수를 높이는 데에도 이점이 있다.\n\n## ISO 계층에서의 역할\n\n- 계층 7: 응용 계층(Application Layer): HTTP, HTTPS 등과 같은 프로토콜을 사용하여 사용자의 요청을 처리하고, 서버로부터의 응답을 제공.\n\n- 계층 6: 표현 계층(Presentation Layer): HTTP, HTTPS 프로토콜 내에서 데이터의 인코딩, 암호화, 압축 등을 담당. \n\n- 계층 5: 세션 계층(Session Layer): TCP의 three-way handshake는 네트워크 상에서 컴퓨터 간의 연결(세션)을 관리합니다.(4 way로 세션을 닫는것 까지)\n\n- 계층 4: 전송 계층(Transport Layer): TCP는 데이터의 전송을 관리하고, 필요한 경우 재전송을 수행하면서 데이터의 신뢰성 있는 전송이 가능.\n\n- 계층 3: 네트워크 계층(Network Layer): IP를 사용하여 데이터 패킷의 라우팅(경로 결정)과 전달.\n",
		"category": "posts",
		"createdAt": 1690606028867,
		"id": "afterdomain-network",
		"tags": ["ETC"],
		"description": "대표 면접질문인 도메인 입력 후 어떤일이 있어나나요? 라는 질문에는 개발자가 알아야할 많은 것들이 담겨있다. 이 포스팅에서는 그 중에서 네그워크에 관련된 이야기를 다룬다. ISO 계층구조를 통해 조금 더 체계적으로 알아보자.",
		"title": "도메인 입력후"
	}
}
