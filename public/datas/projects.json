{
	"blog": {
		"body": "이번 프로젝트는 지금 이 페이지를 담고 있는 웹을 만드는 프로젝트로써 포트폴리오와 블로그 기능을 수행 할 수 있는 개인 웹사이트를 리액트를 사용하여 만드는 일이다. 이곳에 개발과 공부를 하면서 얻은 결과물과 노트를 담는다. 이를 위해 리액트 외에 클라이언트 쪽의 전역 상태를 관리하기 위해 Redux를 사용하였으며 서버쪽 비동기 데이터를 관리하기 위해 React-Query를 사용하으며 서버는 firebase를 통해 구축했다. 사실 블로그는 정적인 페이지 위주로 구성하는 것이 성능면에서 좋겠지만, 이번 프로젝트에서는 스택들을 연습하고 서버와 연동되는 CRUD기능을 구현하는 연습을 하고자 한다.\n\n# Stacks\nReact & typescript : 프로젝트 구성.\n    \nRedux : Client-side 전역 상태를 관리한다. \n\nReact-Query: Server-side 비동기 상태를 관리한다.\n\nfirebase: 서버 구축\n\n\n# 프로젝트 구성\n\n해당 프로젝트는 Home, Posts, 그리고 Projects 페이지로 구성되어 있으며 각 이름에 맞게 Home 페이지에는 웹의 개요, Posts 페이지에는 포스트를 모아 블로그 기능을 하며 Projects 페이지에는 포트폴리오를 구성해 놓았다. 또한 admin권한을 얻으면 Edit 페이지가 추가되어 웹의 컨텐츠를 추가,수정,삭제할 수 있으며 이 데이터들은 firebase에 저장되어 서버 안에서 관리된다. \n\nHeader component\n> Scroll Header로 사용자 스크롤에 반응하여 나타나며 숨는다.\n>로그인 기능을 구현해, 관리자로 로그인 시 게시물을 작성, 수정, 삭제 등 관리할 수 있다.\n\nHome page\n> 블로그에 대한 간단한 소개글과 블로그에 담긴 컨텐츠를 간략하게 나타낸다. \n\nPosts page\n> 사용자가 블로그 내용을 볼 수 있으며, 필터링 기능을 추가하여 프로젝트 목록을 동적으로 렌더링하여 사용자가 관심 있는 주체를 표시한다.\n> 각 `Post Card`는 글의 제목, 작성날짜, 간략한 설명을 제공하며 유저는 해당 카드를 클릭하여 해당 포스트에 대한 상세 페이지로 이동할 수 있다. \n> 관리자 권한을 얻은 사용자의 경우 해당 포스트를 수정, 삭제 할 수 있다. \n\nProjects page\n> Posts page와 마찬가지로 각 `Project card`는 프로젝트의 간략한 정모가 담겨 있으며 유저는 해당 가드를 클릭하여 상세페이지로 이동할 수 있다.\n\nEdit page\n>관리자로 로그인된 사용자는 게시물을 작성, 수정, 삭제할 수 있다. \n\n\n# 주요기능\n반응형 웹 디자인 : 반응형 디자인으로 구성된 블로그 프로젝트는 모바일, 태블릿, 데스크톱 등 다영한 디바이스에서 최적화된 사용자 경험을 제공하고자 노력하였다.\n\n다크모드 : 사용자가 웹의 테마를 전활 할 수 있도록 기능 구현. Tailwindcss와 Redux를 이용해 관리하며 React-helmet-async를 통해 html 태그를 조작하여 구현.\n\nClient side 상태 관리를 위한 Redux 사용: 웹의 주요 데이터라고 할 수 있는 post와 project에 관한 데이터를 이미 react-query에서 관리하고 있기 때문에 해당 규모에서 Redux의 관리가 필요한 전역 상태는 거의 없다. 관리할 전역상태가 많지 않음에도 리덕스의 Reducer방식은 상태 관리를 명료하게 해주는 이점이 있었다. \n\n서버 데이터 관리를 위한 React-query사용: 서버에 와의 통신에서 최신데이터를 관리하고 불필요한 데이터 요청을 막을 수 있다. 이번 프로젝트에서는 컴포넌트 간 데이터 동기화에 많은 이점을 보았다.\n\n# Details\n### 프로젝트 구성\n각 페이지를 먼저 구성하고 그에 필요한 요소들을 컴포넌트로 만들었으며 로직이 커지는 특정 페이지나 컴포넌트는 container를 구성하여 컨테이너에서 비지니스 로직을 처리하고 컴포넌트에서 렌더링을 하는 방식으로 만들었다.\n```js\n📦src\n ┣ 📂components\n ┃ ┣ 📜Button.tsx\n ┃ ┣ 📜Footer.tsx\n ┃ ┣ 📜Header.tsx\n ┃ ┣ 📜HeaderScroll.tsx\n ┃ ┣ 📜Icon.tsx\n ┃ ┣ 📜Login.tsx\n ┃ ┣ 📜Modal.tsx\n ┃ ┣ 📜Nav.tsx\n ┃ ┣ 📜PostCard.tsx\n ┃ ┣ 📜ProjectCard.tsx\n ┃ ┗ 📜Tag.tsx\n ┣ 📂containers\n ┃ ┣ 📜EditPostContainer.tsx\n ┃ ┣ 📜EditProjectContainer.tsx\n ┃ ┣ 📜PostContainer.tsx\n ┃ ┗ 📜PostsContainer.tsx\n ┣ 📂hooks\n ┃ ┣ 📜usePost.ts\n ┃ ┗ 📜useProject.ts\n ┣ 📂pages\n ┃ ┣ 📜EditPost.tsx\n ┃ ┣ 📜EditProject.tsx\n ┃ ┣ 📜Home.tsx\n ┃ ┣ 📜Post.tsx\n ┃ ┣ 📜Posts.tsx\n ┃ ┣ 📜Project.tsx\n ┃ ┗ 📜Projects.tsx\n ┣ 📂redux\n ┃ ┣ 📂slices\n ┃ ┃ ┣ 📜darkModeSlice.ts\n ┃ ┃ ┗ 📜userSlice.ts\n ┃ ┗ 📜store.ts\n ┣ 📂svgs\n ┃ ┣ 📜firebase.svg\n ┃ ┣ 📜query.svg\n ┃ ┣ 📜react.svg\n ┃ ┣ 📜redux.svg\n ┃ ┗ 📜ts.svg\n ┣ 📂utils\n ┃ ┣ 📜Firebase.ts\n ┃ ┗ 📜functions.ts\n ┣ 📜App.css\n ┣ 📜App.tsx\n ┣ 📜defaultvalues.ts\n ┣ 📜index.css\n ┣ 📜index.tsx\n ┣ 📜react-app-env.d.ts\n ┗ 📜type.d.ts\n```\n### styling\nTailwindcss를 이용했다. 자유도는 조금 떨어지지만 색감이나 화면과 컴포넌트 간 스케일을 조절하는데 많이 도움이 된다. `hover:`, `focus:`등을 이용하여 동적인 스타일링이도 가능하여 `dark:`를 이용하여 다크모드도 쉽게 구현할 수 있었다. 또한 `sm:`, `md:`, `lg:`등을 이용해 스크린 크기에 비래에 동적 스타일링도 지원하여 미디어쿼리도 간편하게 구현할 수 있었다. Tailwindcss를 이용한다 하더라도 디자인적 요소를 모두 구성하기엔 능력도 시간도 부족하므로 [참고 사이트](ttps://spotlight.tailwindui.com/)를 클론하였다. \n\n### 상태 관리 툴\n이 프로젝트에서는 전역 상태를 client와 server, 둘로 나눠 관리 했다. react-query 하나로 상태관리를 할 수도 있었지만 이는 react-query의 용도와도 맞지 않을 뿐더러 앞으로 해당 프로젝트가 개인적 용도로 쓰는 웹이지만 결국 앞으로의 프로젝트 규모를 염두해야 하므로 스택을 구분하여 사용할 필요가 있다고 생각했기 때문이다. \n상태 관리툴은 여러가지가 있고 관리해야할 전역 상태가 많지 않으므로 리액트에서 기본으로 제공하는 상태관리 툴인 Context Api가 적당할 것이다. 해당 프로젝트의 복잡성이 높지 않고 보일러 플레이트도 적기 떄문이다. 하지만 리덕스를 사용하면서 상태관리를 이해하고 전역상태의 보호성도 높이면서 실수를 최소화 할수 있다.\n```js\nexport default configureStore({\n\treducer: {\n\t\tuser: userReducer, //\n\t\tfilter: filterReducer,\n\t\tdarkMode: darkModeReducer,\n\t},\n});\n\n```\n### Custom hooks 사용\n비동기 데이터를 가지고 오거나 수정, 삭제 함에 있어 컴포넌트 간 동기화가 제대로 되지 않아 데이터가 혼란스럽게 퍼져있는 느낌을 받아 프로젝트가 전반적으로 산만한 느낌을 주었다. 더욱이 react-query는 `key`를 통해 데이터 fetching을 결정하기 때문에 fetching로직이 컴포넌트 이곳저곳에 퍼져있으면 유지보수에도 좋지 않을뿐더러 프로젝트를 이해하기에 어려움이 따른다. 이떄문에 fetching로직을 한곳에서 관리할 필요성이 있었다. 이에 custom hook인 `useProject`와 `usePost`를 만들어 각 데이터를 관리하는 훅을 하나로 만들어 필요한 컴포넌드에서 불러와 사용하였다. \n```js\nexport default function useProject(id?: string) {\n\tconst queryClient = useQueryClient();\n\n\tconst projectQuery = useQuery([\"projects\"], () => getItems(\"projects\"), {\n\t\tstaleTime: 1000 * 6 * 5,\n\t});\n\n\tconst getProject = useQuery([\"projects\", id], () => getItem(id, \"projects\"), {\n\t\tstaleTime: 1000 * 60 * 5,\n\t});\n  \n    ///////\n    ///////\n  \n  \treturn { projectQuery, getProject, addProject, updateProject, removeProject };\n}\n\n  ```\n### firebase 서버\n  백엔드 스택이 없어서 서버 구축에 어려움이 있으므로 플렛폼을 사용하기로 했다. 파이어베이스 기능중에는 admin권한을 얻기위한 인증 기능과 데이터베이스만 사용했다.\n",
		"category": "projects",
		"createdAt": 1680684398244,
		"detail": "개인 용도의 블로깅, 포르폴리오 게시를 위한 블로그. 게시물 게시와 관리 기능 구현.\n",
		"git": "https://github.com/Latemarch/blog",
		"id": "blog",
		"published": "https://latemarch.netlify.app/",
		"stacks": ["TS", "Query", "Redux", "FB"],
		"title": "Blog"
	},
	"todolist": {
		"body": "이 프로젝트는 학원에서 그룹 프로젝트 전 마지막 과제로 crud가 작동하는 todolist app을 과제로 줘서 firebase를 이용한 리액트 앱을 만들었다. todolist app은 토이프로젝트로 두어번 만들어본 경험이 있기 때문에 이번 프로젝트는 시간을 정하고 시간내에 만드는 것을 목표로 만들어보았다. \n![](https://velog.velcdn.com/images/latemarch/post/c04259f5-3e9b-4861-8b9b-f8078ca6ad23/image.png)\n\n# Stacks\nReact & typescript : 프로젝트 구성.\n    \nRedux : Client-side 전역 상태를 관리한다. \n\nReact-Query: Server-side 비동기 상태를 관리한다.\n\nfirebase: 서버 구축\n\n\n# 프로젝트 구성\n\n해당 프로젝트는 `header`를 포함한 페이지 하나에 리스트를 표시한다. 헤더안에는 `Add` 요소를 넣었으며 `Add`요소를 클릭하면 `input`컴포넌트가 모달로 표시된다. \n![](https://velog.velcdn.com/images/latemarch/post/0ec28293-5ab0-461c-be24-d3f90103a202/image.png)\n\n모달에서 입력된 값은 firebase에 데이터로 추가된다. \n\n\n# 주요기능\n반응형 웹 디자인 : 반응형 디자인으로 구성된 블로그 프로젝트는 모바일, 태블릿, 데스크톱 등 다영한 디바이스에서 최적화된 사용자 경험을 제공하고자 노력하였다.\n\nClient side 상태 관리를 위한 Redux 사용: 모달 창을 제어하기 위해 사용\n\n비동기 상태 관리를 위한 React-query사용: 서버에 와의 통신에서 최신데이터를 관리하고 불필요한 데이터 요청을 막을 수 있다. 이번 프로젝트에서는 컴포넌트 간 데이터 동기화에 많은 이점을 보았다.\n\n# Details\n### 프로젝트 구성\n이번 앱을 만들 때, 요구사항이 몇가지 있었다.\n 1. crud 작동\n 2. redux 사용\n 3. 외부 서버 사용\n\n```js\n📦src\n ┣ 📂components\n ┃ ┣ 📜Button.tsx\n ┃ ┣ 📜ConfirmDelete.tsx\n ┃ ┣ 📜Header.tsx\n ┃ ┣ 📜Input.tsx\n ┃ ┣ 📜Modal.tsx\n ┃ ┣ 📜ToDoCard.tsx\n ┃ ┗ 📜ToDoList.tsx\n ┣ 📂hooks\n ┃ ┗ 📜useToDo.ts\n ┣ 📂redux\n ┃ ┣ 📂slices\n ┃ ┃ ┗ 📜modalSlice.ts\n ┃ ┗ 📜store.ts\n ┣ 📂utils\n ┃ ┗ 📜firebase.ts\n ┣ 📜App.css\n ┣ 📜App.test.tsx\n ┣ 📜App.tsx\n ┣ 📜MainPage.tsx\n ┣ 📜index.css\n ┗ 📜sindex.tsx\n```\n### styling\nTailwindcss를 사용함. 디자인은 이전에 만든 블로그의 디자인을 참고하여 반응형 앱으로 만들었다.\n\n### 상태 관리 툴\n모달창을 제어하기 위해 redux를 이용했다. 모달창은 props에 `children`을 받아 해당 컴포넌트의 container 역할을 한다. 모달창에 prop로 전달되는 컴포넌트는 `Input`과 `ConfirmDelete`가 있다. 각 컴포넌트는 리스트에 요소를 추가하고 요소를 삭제할 때 확인을 받는 일을 한다.\n\n\n### firebase 서버\nList는 firebase서버에서 관리된다.\n\n\n",
		"category": "projects",
		"createdAt": 1680684196902,
		"detail": "CRUD가 작동하는 ToDoList app 만들기, 서버에 데이터를 저장하고 리덕스를 사용",
		"git": "https://github.com/Latemarch/todo-homework",
		"id": "todolist",
		"published": "https://latemarch-todoapp.netlify.app",
		"stacks": ["TS", "Query", "FB", "Redux"],
		"title": "ToDoList"
	},
	"youtube-clone": {
		"body": "유튜브 클론코딩은 토이 프로젝트를 제외하면 첫번째 리액트 프로젝트이다. 유튜브가 제공하는 api를 이용하여 유튜브 사이트의 데이터를 가지고 와 유튜브의 기능과 디자인을 클론했다. fetching 로직에 axios를 사용했다.\n![](https://velog.velcdn.com/images/latemarch/post/4de081ab-4285-4b0e-b075-9fdc1d774b29/image.png)\n\n\n# Stacks\nReact : 프로젝트 구성.\n    \naxios: data fetching\n\n# 프로젝트 구성\n\n해당 프로젝트는 홈 역할을 하는 `videos`page 에서 비디오들을 표시하며, 검색어가 없는 경우 인기비디오 목록을, 검색어가 있는 경우는 검색어에 해당하는 비디오 목록을 보여준다. 검색어에 해당하는 비디오들은 `video card`컴포넌트에 썸네일, 제목, 게시자와 날짜정보를 담고있으며 유저는 비디오 카드를 클릭하여 상제 페이지에 접근할 수 있다. 상세페이지는 비디오의 상세정보와 연관 비디오를 표시한다.  \n\n\nVideos page\n> 비디오 목록 표시 \n\nDetails page\n> 비디오, 비디오 정보, 연관비디오 표시 \n\n# 주요기능\n반응형 웹 디자인 : 반응형 디자인으로 구성된 블로그 프로젝트는 모바일, 태블릿, 데스크톱 등 다영한 디바이스에서 최적화된 사용자 경험을 제공하고자 노력하였다.\n\nYoutube api를 이용한 동기화: youtube사이트의 제공되는 데이터를 그대로 받아와 해당 프로젝트에서도 유튜브의 기능을 일부 구현함.\n\n\n# Details\n### 프로젝트 구성\n각 페이지를 먼저 구성하고 그에 필요한 요소들을 컴포넌트로 만들었으며 로직이 커지는 특정 페이지나 컴포넌트는 container를 구성하여 컨테이너에서 비지니스 로직을 처리하고 컴포넌트에서 렌더링을 하는 방식으로 만들었다.\n```js\n📦Youtube\n ┣ 📂Components\n ┃ ┣ 📜VideoCard.jsx\n ┃ ┗ 📜YoutubeHeader.jsx\n ┣ 📂apis\n ┃ ┗ 📜youtubeApi.js\n ┣ 📂pages\n ┃ ┣ 📜Details.jsx\n ┃ ┣ 📜NotFound.jsx\n ┃ ┗ 📜Videos.jsx\n ┣ 📜AppYoutube.jsx\n ┣ 📜index.css\n ┣ 📜index.jsx\n ┗ 📜package-lock.json\n```\n\n### styling\nTailwindcss를 이용했다. 자유도는 조금 떨어지지만 색감이나 화면과 컴포넌트 간 스케일을 조절하는데 많이 도움이 된다. \n\n# 마치며\n이번 프로젝트는 첫번째 웹 페이지 구현으로 그 기능이 많이 제한적이다. 하지만 리액트의 기본적인 기능을 익히는데 집중했으며 공개된 api를 이용해 봤다.\n",
		"category": "projects",
		"createdAt": 1680684019961,
		"detail": "Youtube api를 이용한 Youtube 클론코딩. 인기 목록, 검색기능과 상세페이지 구현.",
		"git": "https://github.com/Latemarch/ReactAppProjects",
		"id": "youtube-clone",
		"published": "https://latemarch-projects.netlify.app/youtube",
		"stacks": ["React"],
		"title": "Youtube Clone"
	},
	"nextjsblogrefactor": {
		"body": "React를 배우면서 배웠던 스택으로 CRUD가 작동하는 블로그를 만들었다. 하지만 CSR로 작동하는 블로그의 특징때문에 Reactjs는 사실 좋은 솔루션이 되지는 못했다. 정적인 페이지가 주를 이루는 블로그는 SSR이나 SSG로, 서버에서 렌더링이 이루어져야 더 알맞을 것이다. \n\n## React.js 앱으로써의 블로그\n이전 블로그는 배웠던 스택들을 구현하는 데 의미를 둔 블로그다. 이 때문에 불필요하게 앱 자체가 동적으로 제작되었다. CSR로 블로그의 글이 렌더링 되어 유저에게 보여지려면 html 파싱과 js 로드를 기다려야 했으며 js로드 이후, 파이어베이스에 있는 데이터를 가지고 와야 하므로 간단한 블로그 앱이더라도 로딩 화면을 피할 수 없었다. 특히 파이어베이스는 최초 데이터 요청에서 상당한 시간이 걸리므로 앱이 굉장히 무겁게 느껴지는 문제가 있었다.\n\n## Static Site Generation (SSG)\n어차피 정적인 콘텐츠를 담고 있는 블로그라면 빌드 시점에 모든 데이터들을 미리 파싱하여 클라이언트의 서버 페이지 요청이 발생했을 때 html 파일만 전달해 준다면 JS로드, data feching시간을 아낄 수 있으므로 TTFB가 극적으로 개선될 수 있다. (홈 페이지 새로고침 시 LCP: 614.8ms-> 106.7ms)\n\n\n## 프로젝트 구성\n```js\napp\n ┣ posts\n ┃ ┣ [id]\n ┃ ┃ ┗ page.tsx\n ┃ ┗ page.tsx\n ┣ projects\n ┃ ┣ [id]\n ┃ ┃ ┗ page.tsx\n ┃ ┗ page.tsx\n ┣ favicon.ico\n ┣ globals.css\n ┣ layout.tsx\n ┣ page.tsx\n ┗ paper.tsx\n```\n \n 이번 프로젝트는 app router를 사용했다. app router는 page router의 페이지 단위 렌더링과 달리 컴포넌트 단위로 CSR,SRR등 렌더링 방식을 정할 수 있다. app router에 대한 자세한 설명은 [블로그 글](https://latemarch.vercel.app/posts/nextjsapprouter)을 참고. \n블로그 앱은 간단한 구조를 가진다. 리펙터 전과 달리 게시물 작성, 수정, 삭제 기능은 아직 구현되지 않았다. 회원 가입, 댓글 등록, 게시물 관리 등의 기능은 추후에 업데이트 예정이다.\n \n ## Build\n \n ```js\n Route (app)                                Size     First Load JS\n┌ ○ /                                      176 B          83.2 kB\n├ ○ /favicon.ico                           0 B                0 B\n├ ○ /posts                                 2.68 kB        85.7 kB\n├ ● /posts/[id]                            459 B           337 kB\n├   ├ /posts/restful-api\n├   ├ /posts/getserversideprops\n├   ├ /posts/usememo-usecallback\n├   └ [+6 more paths]\n├ ○ /projects                              5 kB             88 kB\n└ ● /projects/[id]                         459 B           337 kB\n    ├ /projects/blog\n    ├ /projects/todolist\n    └ /projects/youtube-clone\n+ First Load JS shared by all              83 kB\n  ├ chunks/2443530c-03f4e6061aebc84c.js    50.5 kB\n  ├ chunks/488-6d17156d7c0e6251.js         24.9 kB\n  ├ chunks/920-31aadbf21b65d7f1.js         5.68 kB\n  ├ chunks/main-app-67e757f6b6d0257e.js    217 B\n  └ chunks/webpack-4a992917812088ee.js     1.73 kB\n\nRoute (pages)                              Size     First Load JS\n─ ○ /404                                   183 B          74.9 kB\n+ First Load JS shared by all              74.7 kB\n  ├ chunks/framework-43665103d101a22d.js   45.1 kB\n  ├ chunks/main-d413b83cec0718ed.js        27.7 kB\n  ├ chunks/pages/_app-b34b2dcd2ffe424c.js  198 B\n  └ chunks/webpack-4a992917812088ee.js     1.73 kB\n\n○  (Static)  automatically rendered as static HTML (uses no initial props)\n●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)\n```\ndynamic routes를 이용해서 블로그 글이 SSG로 빌드 시점에 생성된다. 나머지는 Static페이지로 CSR로 렌더링 되는 페이지는 없다.(client component는 존재함)",
		"category": "projects",
		"createdAt": 1686388952540,
		"detail": "React로 만들었던 블로그를 nextjs의 정적 페이지 빌드를 이용하여 리펙터 함.",
		"git": "https://github.com/Latemarch/blog-nextjs",
		"id": "nextjsblogrefactor",
		"published": "https://latemarch.vercel.app/",
		"stacks": ["Next", "TS"],
		"title": "Next.js 블로그 리펙터"
	},
	"used-car": {
		"body": "상용화를 목표로 중고차 사이트를 만들어 보기로 했다. 보통 소비자는 메인 중고차 사이트에서 매물들을 보고 비교하기 때문에, 개인 중고차 사이트는 유저 편의를 제공하여 이용 시간을 늘리기 보다는 명함으로써 기능이 더 우선시 된다. 또한 자동차의 긴 수명 때문에 구매 후 재방문을 기대하기 힘드므로 회원 관리 기능도 불필요하다. \n\n\n## 구현 기능 (진행중)\n\n위와 같은 이유 때문에 회원 기능들을 모두 비회원 기능들로 전환 해야 할 필요성이 생긴다. \n\n### 전환 기능\n\n- 좋아요 -> 최근 본 상품\n- 개인정보수집,이용 -> 직접연락채널 구현\n- 복합검색기능 -> 간편검색기능, 상사 보유물품 매물 추천\n- 장바구니 -> client에 조건 저장 후 연락 시 정보 전달 기능\n- 게시글 -> 비회원 비밀글 (구현 후순위)\n\n\n## 백엔드\n기본 상품 정보는 유료 api를 활용해 전국 등록 상품을 조회할 수 있다. 하지만 상사 고유 상품 정보를 가져오거나 기본 상품 정보의 가공 필요성 수요가 있을 수 있기 때문에 중간에 nextjs api 서버를 둬서 중개지로 삼는다. \n\n## 프론트엔드\n\n앱은 Next.js를 사용하여 최대한 정적으로 구성한다. 트래픽이 몰리지 않을 것이라 예상되고 상품을 게시하는 사이트 특성 상 서버와 상호작용을 하는것은 사실상 관리자 뿐이기 때문에 최대한 SSR로 페이지 구성을 몰아 넣어도 서버부하를 예상되지 않기 때문이다. 따라서 서버 데이터를 사용하는 페이지는 ISR로 구성하고 나머지는 next.js의 app component를 이용해서 CSR은 제한적으로 사용한다. \n\n## 프로젝트 구성\n```js\nsrc\n ┣ app\n ┃ ┣ products\n ┃ ┃ ┣ [id]\n ┃ ┃ ┃ ┗ page.tsx\n ┃ ┃ ┣ layout.tsx\n ┃ ┃ ┗ page.tsx\n ┃ ┣ favicon.ico\n ┃ ┣ globals.css\n ┃ ┣ layout.tsx\n ┃ ┗ page.tsx\n ┣ components\n ┃ ┣ Category\n ┃ ┃ ┣ Category.tsx\n ┃ ┃ ┣ Company.tsx\n ┃ ┃ ┣ Manufacturer.tsx\n ┃ ┃ ┣ ManufacturerList.tsx\n ┃ ┃ ┣ MileageRange.tsx\n ┃ ┃ ┣ PriceRange.tsx\n ┃ ┃ ┣ VehicleType.tsx\n ┃ ┃ ┣ VehicleTypes.tsx\n ┃ ┃ ┗ YearRange.tsx\n ┃ ┣ Header\n ┃ ┃ ┣ Header.tsx\n ┃ ┃ ┗ SearchInput.tsx\n ┃ ┣ Icons\n ┃ ┃ ┣ ContactIcon.tsx\n ┃ ┃ ┣ FavIcon.tsx\n ┃ ┃ ┣ FixIcon.tsx\n ┃ ┃ ┗ ShareIcon.tsx\n ┃ ┣ ProductDetail\n ┃ ┃ ┣ ImgContainer.tsx\n ┃ ┃ ┣ ProductDescription.tsx\n ┃ ┃ ┣ ProductHeader.tsx\n ┃ ┃ ┣ ProductHistory.tsx\n ┃ ┃ ┣ ProductOptions.tsx\n ┃ ┃ ┣ ProductSidebar.tsx\n ┃ ┃ ┗ RelatedProducts.tsx\n ┃ ┣ ProductsPage\n ┃ ┃ ┣ GeneralList.tsx\n ┃ ┃ ┗ RecommendList.tsx\n ┃ ┣ SearchBox\n ┃ ┃ ┣ Buttons\n ┃ ┃ ┣ CategoryContainer.tsx\n ┃ ┃ ┣ CompanyList.tsx\n ┃ ┃ ┣ ModelList.tsx\n ┃ ┃ ┣ SearchBox.tsx\n ┃ ┃ ┣ SearchModal.tsx\n ┃ ┃ ┣ SelectionButton.tsx\n ┃ ┃ ┣ SelectionContainer.tsx\n ┃ ┃ ┗ SpecificModelList.tsx\n ┃ ┣ SideBar\n ┃ ┃ ┗ SideBar.tsx\n ┃ ┣ Banner.tsx\n ┃ ┣ Footer.tsx\n ┃ ┣ NoticeContainer.tsx\n ┃ ┣ ProductCard.tsx\n ┃ ┗ TagButton.tsx\n ┣ redux\n ┃ ┣ slices\n ┃ ┃ ┣ categorySlice.ts\n ┃ ┃ ┗ simpleCategory.ts\n ┃ ┣ ReduxProvider.tsx\n ┃ ┗ store.ts\n ┣ service\n ┃ ┣ client\n ┃ ┗ server\n ┗ utils\n ┃ ┣ clientSideFetch.ts\n ┃ ┗ utils.ts\n```\n\n",

		"category": "projects",
		"createdAt": 1688646259349,
		"detail": "상용화를 염두해 두고 Next.js로  개인 중고차 딜러의 웹 사이트를 만들었습니다.",
		"git": "https://github.com/Latemarch/second-car",
		"id": "used-car",
		"stacks": ["Next", "PS", "Redux", "TS"],
		"published": "https://worldmotors.vercel.app/",
		"title": "중고차매매"
	},
	"backtest-web-ui": {
		"body": "## Motivation\n메인 프로젝트 말아먹고 nextjs를 공부를 시작하니, 랜더링이니 SEO니 국비에서 리액트로 컴포넌트나 만들고 상태관리나 했던 때는 중요성을 몰랐던 것들이 무더기로 다가오게 됐다. 막상 이렇게 모르는 것이 많다고 느껴지니 취업 지원서를 넣기가 망설여졌고, serverless api, ssr, seo 등 여러 이슈들을 공부 하고 연습하느라 토이프로젝트나 기본 프로젝트를 만들게 되었다. \n간단한 프로젝트더라도 api, 함수 그리고 훅을 만들어서 유저 데이터를 포함한 서비스 데이터의 흐름을 어느정도 통제하고 나면 진이 빠져서 막상 프론트에서는 구현된 기능의 반도 나타내지 못하는 경우가 생겼다. 상황이 이러니 당연하게도, 지금 나의 [블로그](https://latemarch.vercel.app)에 그렇다할 포트폴리오가 없다. \n\n코인이나 주식에 관심이 생겼을 무렵 가끔 스켈핑을 하곤 했는데, 이익은 지속적으로 기대할 수 있었지만 시간과 스트레스가 상당했던 때가 있었다. 할 줄 아는 거라곤 액셀과 c언어가 전부였던 때, 자동매매에 도전하게 됐는데 컴공적 지식이 없으니 엉뚱한 곳에서 시간을 허비하다가 중도 하차한 적이 있다. (백테스트, 시현 모두 완성했지만 관리할 ui를 만들지 못하거나 서버를 구축 하지 못하는 등 스택 부족으로 미루게 됨)\n\n이렇게 시스템 트레이딩이 내 인생의 숙원사업이 되었고, 시간이 흘러 프론트엔드 과정에 들어하게 됐다. 사실 프론트엔드 포트폴리오로 시스템트레이딩 앱을 만드는 것이 좋은 방법은 아닌거 같다. 프론트 외적인 요소들의 일이 훨씬 많고 솔로 프드젝트는 채용시장에서 메리트 있는 포트폴리오는 아니기 때문이다.\n\n## ApexCharts\nApexCharts는 CnadleChart를 지원하면서도 설정 자유도가 높아서 이번 프로젝트에 사용해보기로 했다. 많은 애니메이션 라이브러리가 그렇듯, ApexChart도 ssr을 지원하지 않아, Next.js에서 import 하면 window가 정의되지 않는 오류를 발생시킨다. 개발 환경에서는 문제가 되지 않지만(오류를 무시한다면), 배포 환경에서는 분명히 문제가 되므로 동적 임포트가 필요하다.\n```js\nimport dynamic from \"next/dynamic\";\nconst Chart = dynamic(() => import(\"react-apexcharts\"), {\n\tssr: false,\n});\n```\nApexCharts의 [공식문서](https://apexcharts.com/javascript-chart-demos/pie-charts/simple-donut/)에서 제공하는 pie chart를 그리는 방법을 함수형 컴포넌트로 바꾸면 아래와 같이 사용 할 수 있다.\n\n```js\n\"use client\";\nimport React, { useState } from \"react\";\nimport dynamic from \"next/dynamic\";\nconst ReactApexChart = dynamic(() => import(\"react-apexcharts\"), {\n\tssr: false,\n});\n\ntype Props = {\n\ttitle: string;\n\tdata: { profit: number; loss: number };\n};\n\n//차트 이름(title)과 데이터(이 컴포넌트는 손익 비교만 함)\n//data 갯수는 필요에 따라 늘려서 매핑하면 됨.\nconst PieChart = ({ title, data: { profit, loss } }: Props) => {\n\tconst [chartState, setChartState] = useState({\n\t\tseries: [profit, loss],\n\t\toptions: {\n\t\t\tchart: {\n\t\t\t\ttype: \"donut\" as const,\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\ttext: title,\n\t\t\t\talign: \"left\" as const,\n\t\t\t},\n\t\t\tlabels: [\"Profit\", \"Loss\"],\n\t\t\tcolors: [\"#26A69A\", \"#EF5350\"],\n\n\t\t\tresponsive: [\n\t\t\t\t{\n\t\t\t\t\tbreakpoint: 480,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tchart: {\n\t\t\t\t\t\t\twidth: 200,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlegend: {\n\t\t\t\t\t\t\tposition: \"bottom\" as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t});\n\n\treturn (\n\t\t<div className=\"p-4\">\n\t\t\t<ReactApexChart\n\t\t\t\toptions={chartState.options}\n\t\t\t\tseries={chartState.series}\n\t\t\t\ttype=\"donut\"\n\t\t\t/>\n\t\t</div>\n\t);\n};\n\nexport default PieChart;\n\n```\n\n\n## BackTest\n백테스트 에서는 실전에서 사용할 전략을 지난 틱 거래 데이터에 적용해 예상 수익률을 가늠해 본다. UI를 만들고 나서는 이 백테스트 로직을 수정하는 것이 주요 업무가 될 것이다. UI를 구성하기 위해 수익률은 고려하지 않고, 거래가 일어날만한 로직만 구현해 본다. \n\n#### data fetching\n앞서 설명 했듯이 데이터는 bybit에서 제공하는 틱 데이터를 분봉으로 가공해서 쓴다. 가공된 데이터는 서버에도 업로드 해놨지만, 개발환경에서는 렌더링 방식을 막론하고 페이지가 마운트 될 때마다 데이터 패칭이 일어나므로 로컬에 저장해 놨다. 틱데이터와 달리 가공된 데이터는 60일 데이터분이 5MB에 그치므로 로컬에 데이터를 쓴다. \nnextjs에서 로컬에 저장된 데이터는 리액트의 그것과는 달리 클라이언트 컴포넌트에서는 데이터 패칭이 불가능하다. 서버 컴포넌트로 데이터를 불러와 클라이언트 컴포넌트로 데이터를 전달한다.\n\n#### MACD를 이용한 거래\nMACD는 이동 평균선에 대한지표로 아래 그래프에서의 파란색 막대 그래프가 MACD를 나타낸다. 전략 초안에서는 단순히 MACD가 음수에서 상승추세를 보이면 매수를 하여 지정된 손실제한지점(-1%내외)에 도달하면 손절 하거나 MACD가 양수인 지점에서 n번의 상승을 거듭하면 매도하고 이익 실현 지점(1%내외)에 도달하면 익절한다.\n![](https://velog.velcdn.com/images/latemarch/post/7c0fbb03-4940-4cdc-91bb-694c2a3a177f/image.png)\n\n## 결과 데이터 저장\n백테스트를 마치면 많은 데이터들을 반환한다.아래 데이터들은 초안이고, 필요에 따라 추가 삭제 예정이다.\n```ts\ntype MACDResult = {\n\tma1: ApexChartData[];\n\tma2: ApexChartData[];\n\tmacd: ApexChartData[];\n\tmacdSig: ApexChartData[];\n\tmacdOsc: ApexChartData[];\n\tlong: ApexChartData[];\n\tlongSell: ApexChartData[];\n\tshort: ApexChartData[];\n\tshortSell: ApexChartData[];\n\tdailyResult: DailyResult[];\n\tuploadResult?: UploadDailyResult;\n};\n```\n위 데이터들을 이용해서 전에 보았던 분봉차트를 그리게 된다. 이 데이터의 일부 혹은 전부가 prisma 를 이용해 planet scale에 업로드 된다. \n\n```js\nexport async function POST(req: Request) {\n\tconst request = await req.json();\n\tconst body = await JSON.parse(request.body);\n\tconst {\n\t\tasset,\n\t\tstrategy,\n\t\tconstants,\n\t\tresult: { fluctuation, profitAverage, dailyReturn },\n\t} = body;\n  \n    //업로드 하고자 하는 데이터가 이미 있는지 확인\n\tconst data = await client.bTResult.findFirst({\n\t\twhere: { asset, strategy, constants },\n\t});\n\t\n  \t//데이터가 존재 하는 경우, 메세지와 데이터 반환\n\tif (data) {\n\t\tconsole.log(\"already exsits\");\n\t\treturn NextResponse.json({ ok: false, data });\n\t}\n  \n\t//데이터가 존재하지 않는 경우 데이터 업로드\n\tconst result = await client.bTResult.create({\n\t\tdata: {\n\t\t\tasset,\n\t\t\tstrategy,\n\t\t\tconstants,\n\t\t\t...\n\t\t},\n\t});\n\treturn NextResponse.json({ ok: true, data: result });\n}\n```\n\n## 분석된 결과 저장\n백테스트를 완료한 매매 전략들은 각각의 데이터들을 반환한다. 일일 수익률에 대한 평균, 표준편차, 이들을 용한 평균치 분포, 표준편차 분포등이다. 이 데이터를 가지고도 백테스트가 왜곡된 결과를 주는지에 대한 검증이 가능하다. 가령 수익률의 분포는 정규 분포를 표준편차의 분포는 포아송 분포를 반환한다면 어느정도 데이터의 경향성을 신뢰 할 수 있는 근거가 될 수 있을 것이다. \n또한 전략 설계에 따라 분석할 수 있는 데이터들의 종류와 양은 천차 만별일 것이므로 이를 나타내는 대쉬보드도 더 복잡해 질 것이다.",
		"category": "projects",
		"createdAt": 1690298847580,
		"detail": "자동매매 백테스트 결과를 정리하여 저장하고 실전 거래를 도와줄 개인용 웹 만들기.",
		"stacks": ["Next", "PS", "Redux", "TS"],
		"git": "https://github.com/Latemarch/backtest_web_ui",
		"id": "backtest-web-ui",
		"published": "https://backtest-web.vercel.app/",
		"title": "Backtest web ui(진행중)"
	}
}
